<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat (v9.0 - Tests Separated)</title> <script> window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},svg:{fontCache:'global'},options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}}; </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

    <style>
        /* --- Styles (Mostly unchanged, removed test/review view styles) --- */
        :root { /* ... Theme Variables ... */
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --link-color: #007bff; --link-hover-color: #0056b3; --info-message-bg: #e7f3fe; --info-message-text: #0c5460; --info-message-border: #b8daff;
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --link-color: #6cadff; --link-hover-color: #a3ceff; --info-message-bg: #1c3a4f; --info-message-text: #bee5eb; --info-message-border: #49779c;}
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* --- Layout & Structure --- */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content { display: flex; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 20px 10%; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; /* Initially hidden */ }

        /* --- Sidebar Elements --- */
        .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
        .sidebar-button { /* General purpose button */ display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 5px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; }
        .sidebar-button:hover { background-color: var(--button-hover-bg); }
        .sidebar-button svg { fill: currentColor; width: 16px; height: 16px; }
        .sidebar-button:disabled { opacity: 0.6; cursor: not-allowed; }
        .sidebar-section-title { padding: 15px 20px 5px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; }
        .chat-list { flex-grow: 1; overflow-y: auto; padding: 0 15px; margin-bottom: 10px; }
        .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
        .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
        .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
        .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .chat-list-item:hover .delete-chat-button { display: block; }
        .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
        .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease;}
        .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px; }
        .text-size-controls span, .theme-toggle span, .language-toggle span { font-size: 0.85em; color: var(--text-secondary); }
        .text-size-buttons button, .theme-toggle button, .language-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .text-size-buttons button:hover, .theme-toggle button:hover, .language-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .text-size-buttons button:disabled, .theme-toggle button:disabled, .language-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
        .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
        .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
        .account-details { overflow: hidden; }
        .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .account-plan { font-size: 0.85em; color: var(--text-secondary); }
        #auth-controls { margin-top: 15px; text-align: center; }
        #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
        #auth-controls button:hover { background-color: var(--button-hover-bg); }
        #logout-btn { display: none; }


        /* --- Chat Area Elements --- */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { background-color: var(--info-message-bg); color: var(--info-message-text); border: 1px solid var(--info-message-border); padding: 10px 15px; border-radius: 8px; margin-top: 10px; font-size: 0.95em; }
        .info-message a { color: var(--link-color); text-decoration: none; font-weight: 500; } .info-message a:hover { color: var(--link-hover-color); text-decoration: underline; }
        .message mjx-container { color: inherit !important; font-size: inherit !important; }

        /* --- Input Area Elements --- */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--accent-color); }
        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }
        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }

    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <div class="sidebar">
            <div class="sidebar-header" data-translate-key="appTitle">Gemini Chat</div>

            <button class="sidebar-button" id="start-chat" disabled>
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                <span data-translate-key="newChat">புதிய உரையாடல்</span>
            </button>

            <button class="sidebar-button" id="goto-tests-page" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm80-80h400v-80H280v80Zm0-120h400v-80H280v80Zm0-120h400v-80H280v80Zm0-120h160v-80H280v80Zm240 0h160v-80H520v80Z"/></svg>
                <span data-translate-key="manageTests">சோதனைகளை நிர்வகி</span>
            </button>

            <div class="sidebar-section-title" data-translate-key="chats">உரையாடல்கள்</div>
            <div class="chat-list" id="chat-list">
                <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;" data-translate-key="loginToSeeChats">உரையாடல்களைப் பார்க்க உள்நுழையவும்.</div>
            </div>
            <div class="sidebar-footer">
                <div class="sidebar-controls">
                    <div class="text-size-controls">
                        <span data-translate-key="textSize">எழுத்து அளவு</span>
                        <div class="text-size-buttons">
                            <button id="decrease-text-size" title="Decrease text size" disabled>-</button>
                            <button id="increase-text-size" title="Increase text size" disabled>+</button>
                        </div>
                    </div>
                    <div class="theme-toggle">
                        <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button>
                    </div>
                     <div class="language-toggle">
                        <button id="language-toggle-button" title="Switch Language" disabled>தமிழ்</button>
                    </div>
                </div>
                <div id="auth-controls">
                    <button id="login-google-btn" data-translate-key="loginGoogle">Google மூலம் உள்நுழைக</button>
                    <button id="logout-btn" style="display: none;" data-translate-key="logout">வெளியேறு</button>
                </div>
                <div class="account-info">
                    <div class="account-avatar" id="account-avatar">?</div>
                    <div class="account-details">
                        <div class="account-email" id="account-email" data-translate-key="notLoggedIn">உள்நுழையவில்லை</div>
                        <div class="account-plan" id="account-plan"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                <div class="chat-area" id="chat-area">
                    </div>
                <div class="input-container" id="input-container">
                    <div class="suggestions" id="suggestions">
                        </div>
                   <div class="input-box">
                        <textarea id="user-input" placeholder="..." rows="1"></textarea>
                        <div class="mcq-mode-control">
                            <input type="checkbox" id="mcq-mode-checkbox" title="...">
                            <label for="mcq-mode-checkbox" id="mcq-label">MCQs?</label>
                        </div>
                        <button id="send-button" title="..." disabled>
                            <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                </div>
            </div>
             </div>
    </div>

    <script>
        // --- Firebase Config ---
        // !!! SECURITY WARNING !!! Replace with your actual config. RESTRICT YOUR API KEY!
        const firebaseConfig = {
         apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- SHARED, INSECURE KEY - REPLACE AND SECURE!
         authDomain: "krish-c5db8.firebaseapp.com",
         projectId: "krish-c5db8",
         storageBucket: "krish-c5db8.appspot.com",
         messagingSenderId: "217175257890",
         appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
         measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const gotoTestsButton = document.getElementById('goto-tests-page');
        const chatListContainer = document.getElementById('chat-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const languageToggleButton = document.getElementById('language-toggle-button');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const mcqLabel = document.getElementById('mcq-label');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');

        // --- Config & Constants ---
        const MODEL_NAME = "gemini-1.5-flash-latest";
        const API_URL_BASE = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=`;
        const STORAGE_KEY_API_KEY = 'geminiApiKey';
        const STORAGE_KEY_SETTINGS = 'geminiChatSettings_v2'; // Changed key to reset old settings if needed
        const NEW_CHAT_KEY = "newChatUntitled"; // Key for translation
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️';
        const DARK_THEME_ICON = '🌙';
        const DELETE_ICON = '×';
        const TESTS_PAGE_URL = 'tests.html'; // URL for the new tests page

        // --- Translations ---
        const translations = {
            en: {
                appTitle: "Gemini Chat",
                newChat: "New Chat",
                manageTests: "Manage Tests",
                chats: "Chats",
                loginToSeeChats: "Login to see chats.",
                noChatsYet: "No conversations yet.",
                errorLoadingChats: "Error loading chats.",
                deleteChat: "Delete Chat",
                confirmDelete: 'Permanently delete "{chatTitle}" and all its messages?',
                deletingChat: "Deleting chat...",
                errorDeletingChat: "Could not delete chat. Check permissions or connection.",
                textSize: "Text Size",
                decreaseTextSize: "Decrease text size",
                increaseTextSize: "Increase text size",
                toggleThemeLight: "Light Mode",
                toggleThemeDark: "Dark Mode",
                switchLanguage: "Switch Language",
                languageName: "English",
                loginGoogle: "Login with Google",
                logout: "Logout",
                notLoggedIn: "Not logged in",
                firebaseUser: "Firebase User",
                greeting: "Hello, {userName}!",
                welcome: "Welcome!",
                selectOrCreateChat: "Select a conversation or start a new one.",
                loginToStart: "Please log in using the Google button in the sidebar to start chatting or view your history.",
                enterQuestion: "Enter a question...",
                enterQuestionMCQ: "Enter prompt for MCQs...",
                mcqCheckboxLabel: "Generate MCQs?",
                mcqCheckboxTitle: "Check this to generate Multiple Choice Questions based on your prompt.",
                send: "Send",
                sending: "Sending...",
                thinking: "Thinking...",
                loadingChat: "Loading conversation...",
                errorApiKey: "Gemini API Key not set.",
                errorLogin: "Please log in.",
                errorSelectChat: "Please select or create a conversation.",
                errorSend: "Could not send message. Please try again.",
                errorSaveUserMsg: "Error saving your message.",
                errorSaveAiMsg: "Error saving response. It might not appear.",
                errorFetch: "Network error or issue during request.",
                errorApiGeneric: "API Error",
                errorApiKeyInvalid: "Invalid Gemini API Key removed. Reload to enter a new one.",
                errorApiResponse: "Error: Could not extract valid text from response.",
                responseBlocked: "Blocked: {reason}",
                emptyResponse: "Sorry, received an empty response.",
                mcqCreated: 'MCQs created successfully! You can find and take this test on the <a href="{testsPageUrl}" target="_blank">Manage Tests</a> page.',
                errorMCQSave: "MCQs generated, but failed to save the test definition to the database.",
                errorMCQParse: "Failed to parse MCQ JSON from response.",
                errorMCQFormat: "AI response for MCQs was not in the expected JSON array format.",
                errorMCQValidation: "MCQ JSON validation failed (missing question, options, or answer).",
                generatingTitle: "Generating title...",
                errorCheckingFirstMsg: "Error checking for first message.",
                errorUpdatingTitle: "Error updating chat title in Firestore.",
                chatTitleUpdated: "Chat title automatically updated: {title}",
                newChatUntitled: "(Untitled Chat)",
                suggestionHistory: "5 Qs US History",
                suggestionRecursion: "What is recursion?",
                suggestionLimit: "Explain sin(x)/x limit",
                apiKeyPrompt: "--- INSECURE DEMO ---\nPlease enter your Gemini API Key (stored in local storage - use Cloud Function for security):",
                apiKeyNeeded: "Gemini API Key needed. Please reload.",
                apiKeyMissing: "API Key missing",
                loginInProgress: "Logging in...",
                logoutInProgress: "Logging out...",
                errorLoginFailed: "Login failed: {message}",
                errorLogoutFailed: "Logout failed: {message}",
                userLoggedIn: "User logged in:",
                userLoggedOut: "User logged out",
                loadingUserSettings: "Loading user settings...",
                errorLoadingSettings: "Error loading user settings:",
                errorSavingSettings: "Error saving user settings:",
                listeningChats: "Listening for chats for user {userId}",
                chatListSnapshot: "Chat list snapshot received:",
                deletingChatSkip: "Skipping chat list update during delete.",
                activeChatNoExist: "Active chat doesn't exist or was deleted, selecting newest:",
                noChatsForUser: "User has no chats.",
                switchingChat: "Switching chat:",
                errorListeningChats: "Error listening to chat list:",
                errorLoadingChatList: "Failed to load chat list.",
                chatTitleInvalid: "(Invalid Title)",
                listeningMessages: "Listening for messages for chat {chatId}",
                chatMessagesSnapshot: "Chat {chatId} messages snapshot received: {count} messages",
                chatIsEmpty: "Conversation is empty.",
                errorListeningMessages: "Error listening to messages for chat {chatId}:",
                errorLoadingMessages: "Could not load messages for this conversation.",
                savingUserMsg: "User message saved to Firestore.",
                firstMsgCheck: "First user message, attempting title generation.",
                insecureApiCall: "SECURITY WARNING: Calling Gemini API with client-side key.",
                savingAiMsg: "AI response/error saved to Firestore.",
                mcqsParsedSuccess: "MCQs parsed successfully, saving to /tests collection:",
                savingTestDef: "Saving test definition to Firestore...",
                savingTestDefSuccess: "Test definition saved successfully with ID: {testId}",
                normalAiResponse: "Saving normal AI response."
            },
            ta: {
                appTitle: "ஜெமினி அரட்டை",
                newChat: "புதிய உரையாடல்",
                manageTests: "சோதனைகளை நிர்வகி",
                chats: "உரையாடல்கள்",
                loginToSeeChats: "உரையாடல்களைப் பார்க்க உள்நுழையவும்.",
                noChatsYet: "இன்னும் உரையாடல்கள் இல்லை.",
                errorLoadingChats: "உரையாடல்களை ஏற்றுவதில் பிழை.",
                deleteChat: "உரையாடலை நீக்கு",
                confirmDelete: '"{chatTitle}" மற்றும் அதன் அனைத்து செய்திகளையும் நிரந்தரமாக நீக்க விரும்புகிறீர்களா?',
                deletingChat: "உரையாடலை நீக்குகிறது...",
                errorDeletingChat: "உரையாடலை நீக்க முடியவில்லை. அனுமதிகள் அல்லது இணைப்பைச் சரிபார்க்கவும்.",
                textSize: "எழுத்து அளவு",
                decreaseTextSize: "எழுத்து அளவைக் குறைக்கவும்",
                increaseTextSize: "எழுத்து அளவை அதிகரிக்கவும்",
                toggleThemeLight: "ஒளி பயன்முறை",
                toggleThemeDark: "இருண்ட பயன்முறை",
                switchLanguage: "மொழியை மாற்று",
                languageName: "தமிழ்",
                loginGoogle: "Google மூலம் உள்நுழைக",
                logout: "வெளியேறு",
                notLoggedIn: "உள்நுழையவில்லை",
                firebaseUser: "Firebase பயனர்",
                greeting: "வணக்கம், {userName}!",
                welcome: "வருக!",
                selectOrCreateChat: "ஒரு உரையாடலைத் தேர்ந்தெடுக்கவும் அல்லது புதியதாகத் தொடங்கவும்.",
                loginToStart: "அரட்டையைத் தொடங்க அல்லது உங்கள் வரலாற்றைக் காண sidebar-இல் உள்ள Google பொத்தானைப் பயன்படுத்தி உள்நுழையவும்.",
                enterQuestion: "கேள்வியை உள்ளிடவும்...",
                enterQuestionMCQ: "MCQ-களுக்கான தூண்டலை உள்ளிடவும்...",
                mcqCheckboxLabel: "MCQ-களை உருவாக்கு?",
                mcqCheckboxTitle: "உங்கள் தூண்டலின் அடிப்படையில் பல தேர்வு கேள்விகளை உருவாக்க இதைத் தேர்வுசெய்க.",
                send: "அனுப்பு",
                sending: "அனுப்புகிறது...",
                thinking: "சிந்திக்கிறது...",
                loadingChat: "உரையாடலை ஏற்றுகிறது...",
                errorApiKey: "Gemini API Key அமைக்கப்படவில்லை.",
                errorLogin: "தயவுசெய்து உள்நுழையவும்.",
                errorSelectChat: "தயவுசெய்து ஒரு உரையாடலைத் தேர்ந்தெடுக்கவும் அல்லது உருவாக்கவும்.",
                errorSend: "செய்தியை அனுப்ப முடியவில்லை. மீண்டும் முயற்சிக்கவும்.",
                errorSaveUserMsg: "உங்கள் செய்தியைச் சேமிப்பதில் பிழை.",
                errorSaveAiMsg: "பதிலைச் சேமிப்பதில் பிழை. அது தோன்றாமல் போகலாம்.",
                errorFetch: "பிணையப் பிழை அல்லது கோரிக்கையின் போது சிக்கல்.",
                errorApiGeneric: "API பிழை",
                errorApiKeyInvalid: "தவறான Gemini API Key நீக்கப்பட்டது. புதியதை உள்ளிட மீண்டும் ஏற்றவும்.",
                errorApiResponse: "பிழை: பதிலிலிருந்து சரியான உரையைப் பிரிக்க முடியவில்லை.",
                responseBlocked: "தடுக்கப்பட்டது: {reason}",
                emptyResponse: "மன்னிக்கவும், வெற்றுப் பதில் கிடைத்தது.",
                mcqCreated: 'MCQகள் வெற்றிகரமாக உருவாக்கப்பட்டன! இந்த சோதனையை <a href="{testsPageUrl}" target="_blank">சோதனைகளை நிர்வகி</a> பக்கத்தில் காணலாம் மற்றும் எடுக்கலாம்.',
                errorMCQSave: "MCQகள் உருவாக்கப்பட்டன, ஆனால் சோதனை வரையறையை தரவுத்தளத்தில் சேமிக்க முடியவில்லை.",
                errorMCQParse: "பதிலிலிருந்து MCQ JSON-ஐப் பிரித்தெடுப்பதில் தோல்வி.",
                errorMCQFormat: "MCQ-களுக்கான AI பதில் எதிர்பார்க்கப்பட்ட JSON வரிசை வடிவத்தில் இல்லை.",
                errorMCQValidation: "MCQ JSON சரிபார்ப்பு தோல்வி (கேள்வி, விருப்பங்கள் அல்லது பதில் இல்லை).",
                generatingTitle: "தலைப்பை உருவாக்குகிறது...",
                errorCheckingFirstMsg: "முதல் செய்தியைச் சரிபார்ப்பதில் பிழை:",
                errorUpdatingTitle: "Firestore-இல் அரட்டை தலைப்பைப் புதுப்பிப்பதில் பிழை:",
                chatTitleUpdated: "அரட்டை தலைப்பு தானாகப் புதுப்பிக்கப்பட்டது: {title}",
                newChatUntitled: "(பெயரிடப்படாத அரட்டை)",
                suggestionHistory: "5 Qs US வரலாறு",
                suggestionRecursion: "Recursion என்றால் என்ன?",
                suggestionLimit: "sin(x)/x எல்லையை விளக்கு",
                apiKeyPrompt: "--- பாதுகாப்பற்ற டெமோ ---\nஉங்கள் Gemini API Key-ஐ உள்ளிடவும் (இது local storage-இல் சேமிக்கப்படும் - பாதுகாப்பிற்கு Cloud Function தேவை):",
                apiKeyNeeded: "Gemini API Key தேவை. மீண்டும் ஏற்றவும்.",
                apiKeyMissing: "API Key இல்லை",
                loginInProgress: "உள்நுழைகிறது...",
                logoutInProgress: "வெளியேறுகிறது...",
                errorLoginFailed: "உள்நுழைவு தோல்வி: {message}",
                errorLogoutFailed: "வெளியேறுதல் தோல்வி: {message}",
                userLoggedIn: "பயனர் உள்நுழைந்துள்ளார்:",
                userLoggedOut: "பயனர் வெளியேறிவிட்டார்",
                loadingUserSettings: "பயனர் அமைப்புகளை ஏற்றுகிறது...",
                errorLoadingSettings: "பயனர் அமைப்புகளை ஏற்றுவதில் பிழை:",
                errorSavingSettings: "பயனர் அமைப்புகளைச் சேமிப்பதில் பிழை:",
                listeningChats: "{userId} பயனருக்கான அரட்டைகளைக் கவனிக்கிறது",
                chatListSnapshot: "அரட்டை பட்டியல் snapshot கிடைத்தது:",
                deletingChatSkip: "நீக்கும்போது அரட்டை பட்டியல் புதுப்பிப்பு தவிர்க்கப்பட்டது.",
                activeChatNoExist: "செயலில் உள்ள அரட்டை இல்லை/நீக்கப்பட்டது, புதியது தேர்ந்தெடுக்கப்பட்டது:",
                noChatsForUser: "பயனருக்கு அரட்டைகள் இல்லை.",
                switchingChat: "அரட்டை மாறுகிறது:",
                errorListeningChats: "அரட்டை பட்டியலைக் கவனிப்பதில் பிழை:",
                errorLoadingChatList: "அரட்டை பட்டியலை ஏற்ற முடியவில்லை.",
                chatTitleInvalid: "(தவறான தலைப்பு)",
                listeningMessages: "{chatId} அரட்டைக்கான செய்திகளைக் கவனிக்கிறது",
                chatMessagesSnapshot: "{chatId} அரட்டை செய்திகள் snapshot கிடைத்தது: {count} செய்திகள்",
                chatIsEmpty: "உரையாடல் காலியாக உள்ளது.",
                errorListeningMessages: "{chatId} அரட்டை செய்திகளைக் கவனிப்பதில் பிழை:",
                errorLoadingMessages: "இந்த உரையாடலின் செய்திகளை ஏற்ற முடியவில்லை.",
                savingUserMsg: "பயனர் செய்தி Firestore-இல் சேமிக்கப்பட்டது.",
                firstMsgCheck: "முதல் பயனர் செய்தி, தலைப்பு உருவாக்க முயற்சி.",
                insecureApiCall: "பாதுகாப்பு எச்சரிக்கை: Client-side key உடன் Gemini API அழைக்கப்படுகிறது.",
                savingAiMsg: "AI பதில்/பிழை Firestore-இல் சேமிக்கப்பட்டது.",
                mcqsParsedSuccess: "MCQகள் வெற்றிகரமாகப் பிரிக்கப்பட்டு, /tests collection-இல் சேமிக்கப்படுகின்றன:",
                savingTestDef: "சோதனை வரையறையை Firestore-இல் சேமிக்கிறது...",
                savingTestDefSuccess: "சோதனை வரையறை ID: {testId} உடன் வெற்றிகரமாகச் சேமிக்கப்பட்டது",
                normalAiResponse: "சாதாரண AI பதிலைச் சேமிக்கிறது."
            }
        };
        let currentLanguage = 'ta'; // Default language

        // --- State Variables ---
        let API_KEY = '';
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = []; // For API context only
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let activeChatListener = null;
        let chatListListener = null;
        let isDeletingChat = false;
        let userSettingsListener = null; // Listener for user settings document

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        gotoTestsButton.addEventListener('click', () => { window.open(TESTS_PAGE_URL, '_blank'); }); // Open tests page in new tab
        chatListContainer.addEventListener('click', handleChatListClick);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        languageToggleButton.addEventListener('click', toggleLanguage);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);

        // --- Initialization Functions ---
        async function initializeApp() {
            loadGeminiApiKey();
            fbAuth.onAuthStateChanged(handleAuthStateChange);
            userInput.focus();
            updateUIText(); // Initial UI text update
        }

        function loadGeminiApiKey() {
            console.warn(getText('insecureApiCall'));
            const k = localStorage.getItem(STORAGE_KEY_API_KEY);
            if (k) { API_KEY = k; }
            else {
                API_KEY = prompt(getText('apiKeyPrompt'));
                if (API_KEY) { localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); }
                else { displayError(getText('apiKeyNeeded')); setLoadingState(true, getText('apiKeyMissing')); }
            }
            if (API_KEY) setLoadingState(false);
        }

        // --- Translation Function ---
        function getText(key, replacements = {}) {
            let text = translations[currentLanguage]?.[key] || translations['en']?.[key] || `Missing Key: ${key}`;
            for (const placeholder in replacements) {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return text;
        }

        // --- Update UI Text based on Language ---
        function updateUIText() {
            // Update all elements with data-translate-key attribute
            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.dataset.translateKey;
                // Use innerText or textContent based on element type if needed, default to textContent
                if (el.tagName === 'BUTTON' || el.tagName === 'SPAN' || el.tagName === 'DIV' || el.tagName === 'LABEL' || el.tagName === 'A') {
                     // Handle potential nested elements like icons in buttons
                    const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
                    if (textNode) {
                        textNode.textContent = getText(key);
                    } else if (el.textContent) {
                         // Fallback for simple elements
                         el.textContent = getText(key);
                    }
                } else {
                     el.textContent = getText(key); // Or handle other attributes like placeholder, title
                }
            });

            // Update specific elements without data-translate-key
            userInput.placeholder = mcqModeCheckbox.checked ? getText('enterQuestionMCQ') : getText('enterQuestion');
            decreaseTextBtn.title = getText('decreaseTextSize');
            increaseTextBtn.title = getText('increaseTextSize');
            themeToggleButton.title = currentTheme === 'light' ? getText('toggleThemeDark') : getText('toggleThemeLight');
            languageToggleButton.title = getText('switchLanguage');
            languageToggleButton.textContent = getText('languageName'); // Show the *other* language name? Or current? Let's show current.
            mcqLabel.textContent = getText('mcqCheckboxLabel');
            mcqModeCheckbox.title = getText('mcqCheckboxTitle');
            sendButton.title = getText('send');

            // Update account status text if needed (handled mostly in authStateChange)
            if (!currentUser) {
                 accountEmail.textContent = getText('notLoggedIn');
                 chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${getText('loginToSeeChats')}</div>`;
            }

            // Update suggestions
             suggestionsContainer.innerHTML = `
                 <button class="suggestion-chip" data-prompt="5 questions about US History">${getText('suggestionHistory')} (MCQ?)</button>
                 <button class="suggestion-chip" data-prompt="What is recursion?">${getText('suggestionRecursion')}</button>
                 <button class="suggestion-chip" data-prompt="Explain $\\lim_{x\\to 0} \\frac{\\sin x}{x} = 1$">${getText('suggestionLimit')}</button>
             `;

            // Update thinking/loading messages if they exist
            const thinkingMsg = chatArea.querySelector('.thinking');
            if (thinkingMsg) thinkingMsg.textContent = getText('thinking');
            // Similarly update other status messages if needed

            // Update greeting
             renderGreetingOrLoginPrompt(); // Re-render greeting with current language
        }


        // --- Authentication Functions ---
        async function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                setLoadingState(true, getText('loginInProgress'));
                await fbAuth.signInWithPopup(provider);
                // handleAuthStateChange will be triggered
            } catch (error) {
                console.error("Google login error:", error);
                displayError(getText('errorLoginFailed', { message: error.message }));
                setLoadingState(false);
            }
        }

        async function signOut() {
            try {
                setLoadingState(true, getText('logoutInProgress'));
                await fbAuth.signOut();
                 // handleAuthStateChange will be triggered
            } catch (error) {
                console.error("Logout error:", error);
                displayError(getText('errorLogoutFailed', { message: error.message }));
                setLoadingState(false);
            }
        }

        function handleAuthStateChange(user) {
            // Clean up previous listeners
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            if (chatListListener) { chatListListener(); chatListListener = null; }
            if (userSettingsListener) { userSettingsListener(); userSettingsListener = null; } // Detach settings listener

            chatArea.innerHTML = '';
            chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${getText('loginToSeeChats')}</div>`;
            activeChatId = null;
            currentChatHistory = [];

            if (user) { // User is signed in
                currentUser = user;
                console.log(getText('userLoggedIn'), currentUser.uid, currentUser.displayName || currentUser.email);
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = getText('firebaseUser');
                startChatButton.disabled = false;
                gotoTestsButton.disabled = false; // Enable tests button
                decreaseTextBtn.disabled = false;
                increaseTextBtn.disabled = false;
                themeToggleButton.disabled = false;
                languageToggleButton.disabled = false;
                sendButton.disabled = false; // Re-enabled, but handleSendMessage checks activeChatId
                userInput.disabled = false;
                mcqModeCheckbox.disabled = false;
                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';

                listenUserSettings(currentUser.uid); // Load and listen for settings (theme, lang, size)
                loadAndListenForChats(currentUser.uid);

            } else { // User is signed out
                currentUser = null;
                console.log(getText('userLoggedOut'));
                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                accountEmail.textContent = getText('notLoggedIn');
                accountAvatar.textContent = '?';
                accountPlan.textContent = "";
                startChatButton.disabled = true;
                gotoTestsButton.disabled = true; // Disable tests button
                decreaseTextBtn.disabled = true;
                increaseTextBtn.disabled = true;
                themeToggleButton.disabled = true;
                languageToggleButton.disabled = true;
                sendButton.disabled = true;
                userInput.disabled = true;
                mcqModeCheckbox.disabled = true;
                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';

                // Reset to defaults on logout
                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();
                currentLanguage = 'ta'; updateUIText(); // Reset language and update UI

                renderGreetingOrLoginPrompt();
            }
             updateUIText(); // Ensure UI text is correct after login/logout state change
             setLoadingState(false); // Ensure loading state is reset
        }

        function renderGreetingOrLoginPrompt() {
             // Only render if no active chat is loaded or user is logged out
             if (chatArea.querySelector('.message')) return; // Don't overwrite existing messages

            chatArea.innerHTML = ''; // Clear previous greeting if any
            const g = document.createElement('div');
            g.classList.add('greeting');
            if (currentUser) {
                g.innerHTML = `<span class="asterisk">*</span>${getText('greeting', { userName: currentUser.displayName || 'பயனர்' })}`;
                chatArea.appendChild(g);
                if (!activeChatId) {
                    displayMessage(getText('selectOrCreateChat'), 'ai');
                }
            } else {
                g.innerHTML = `<span class="asterisk">*</span>${getText('welcome')}`;
                chatArea.appendChild(g);
                displayMessage(getText('loginToStart'), 'ai');
            }
            scrollToBottom(true);
        }

        // --- Settings (Theme/Text Size/Language) Functions ---
         function listenUserSettings(userId) {
             if (userSettingsListener) userSettingsListener(); // Detach previous listener

             const userDocRef = db.collection('users').doc(userId);
             console.log(getText('loadingUserSettings'));

             userSettingsListener = userDocRef.onSnapshot(docSnap => {
                 if (docSnap.exists) {
                     const settings = docSnap.data();
                     let changed = false;
                     if (settings.theme && settings.theme !== currentTheme) {
                         currentTheme = settings.theme;
                         applyTheme();
                         changed = true;
                     }
                     if (settings.textSizeMultiplier && settings.textSizeMultiplier !== currentTextSizeMultiplier) {
                         currentTextSizeMultiplier = settings.textSizeMultiplier;
                         applyTextSize();
                         changed = true;
                     }
                      if (settings.language && settings.language !== currentLanguage) {
                         currentLanguage = settings.language;
                         // Don't call updateUIText here directly, leads to loops sometimes
                         // Instead, just update the toggle button state
                         languageToggleButton.textContent = getText('languageName');
                         changed = true;
                         updateUIText(); // Update UI if language loaded from settings
                     }

                 } else {
                     // No settings found, save defaults
                     console.log("No user settings found, creating default settings.");
                     currentTheme = 'light';
                     currentTextSizeMultiplier = 1.0;
                     currentLanguage = 'ta'; // Default to Tamil
                     saveUserSettings(); // Save defaults
                     applyTheme();
                     applyTextSize();
                     updateUIText(); // Update UI with defaults
                 }
             }, error => {
                 console.error(getText('errorLoadingSettings'), error);
                 // Apply defaults if loading fails
                 currentTheme = 'light'; applyTheme();
                 currentTextSizeMultiplier = 1.0; applyTextSize();
                 currentLanguage = 'ta'; updateUIText();
             });
         }

        async function saveUserSettings() {
            if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = {
                theme: currentTheme,
                textSizeMultiplier: currentTextSizeMultiplier,
                language: currentLanguage
            };
            try {
                await userDocRef.set(settings, { merge: true });
            } catch (error) {
                console.error(getText('errorSavingSettings'), error);
            }
        }

        function applyTheme() {
             if (currentTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeToggleButton.textContent = LIGHT_THEME_ICON;
                themeToggleButton.title = getText('toggleThemeLight');
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent = DARK_THEME_ICON;
                themeToggleButton.title = getText('toggleThemeDark');
            }
        }

        function toggleTheme() {
            if (!currentUser) return;
            currentTheme = (currentTheme === 'light') ? 'dark' : 'light';
            applyTheme();
            saveUserSettings();
        }

         function applyTextSize() {
            const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`;
            document.documentElement.style.setProperty('--message-font-size', newSize);
            // Enable/disable buttons based on limits
            decreaseTextBtn.disabled = currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
        }


        function adjustTextSize(change) {
            if (!currentUser) return;
            let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change));
            newMultiplier = Math.round(newMultiplier * 10) / 10; // Round to one decimal place
            if (newMultiplier !== currentTextSizeMultiplier) {
                currentTextSizeMultiplier = newMultiplier;
                applyTextSize();
                saveUserSettings();
            }
        }

        function toggleLanguage() {
            if (!currentUser) return;
            currentLanguage = (currentLanguage === 'ta') ? 'en' : 'ta';
            updateUIText(); // Update all UI text
            saveUserSettings();
             // Maybe reload chat history or messages if they contain language-specific system messages?
             // For now, just update UI elements.
        }

        // --- Chat Storage & Loading (Firestore) ---

        function loadAndListenForChats(userId) {
             if (chatListListener) { chatListListener(); chatListListener = null; }

             const chatsRef = db.collection('chats')
                 .where('userId', '==', userId)
                 .orderBy('lastUpdated', 'desc');

             console.log(getText('listeningChats', { userId: userId }));
             chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) {
                     console.log(getText('deletingChatSkip'));
                     return;
                 }
                 const chats = [];
                 snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); });
                 console.log(getText('chatListSnapshot'), chats.length);
                 renderSidebarChatList(chats);

                 let chatToLoad = null;
                 if (activeChatId && chats.some(c => c.id === activeChatId)) {
                     chatToLoad = activeChatId;
                 } else if (chats.length > 0) {
                      chatToLoad = chats[0].id;
                      console.log(getText('activeChatNoExist'), chatToLoad);
                 } else {
                     console.log(getText('noChatsForUser'));
                     activeChatId = null;
                     if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                     currentChatHistory = [];
                     chatArea.innerHTML = ''; // Clear area if no chats exist
                     renderGreetingOrLoginPrompt();
                 }

                 if (chatToLoad && chatToLoad !== activeChatId) {
                     console.log(getText('switchingChat'), chatToLoad);
                     switchChat(chatToLoad);
                 } else if (activeChatId) {
                     highlightActiveChatInSidebar(); // Just highlight if no change
                 }

             }, error => {
                 console.error(getText('errorListeningChats'), error);
                 displayError(getText('errorLoadingChatList'));
                 chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${getText('errorLoadingChats')}</div>`;
             });
        }

        function renderSidebarChatList(chats) {
            chatListContainer.innerHTML = '';
            if (!currentUser) {
                chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${getText('loginToSeeChats')}</div>`;
                return;
            }
            if (chats.length === 0) {
                const i = document.createElement('div');
                i.textContent = getText('noChatsYet');
                i.style.padding = '10px'; i.style.color = 'var(--text-secondary)'; i.style.fontSize = '0.9em';
                chatListContainer.appendChild(i);
            } else {
                chats.forEach(c => {
                    const i = document.createElement('div');
                    i.classList.add('chat-list-item');
                    let title = c.title || getText(NEW_CHAT_KEY); // Use translated untitled
                    // Basic check if title is reasonable string, fallback if not
                    if (typeof title !== 'string' || title.length > 100) title = getText(NEW_CHAT_KEY);
                    i.textContent = title;
                    i.dataset.id = c.id;
                    i.title = title;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-chat-button');
                    deleteBtn.innerHTML = DELETE_ICON;
                    deleteBtn.title = getText('deleteChat');
                    deleteBtn.dataset.id = c.id;
                    i.appendChild(deleteBtn);

                    chatListContainer.appendChild(i);
                });
            }
            highlightActiveChatInSidebar();
        }

        function highlightActiveChatInSidebar() {
            const items = chatListContainer.querySelectorAll('.chat-list-item');
            items.forEach(item => {
                item.classList.toggle('active', item.dataset.id === activeChatId);
            });
        }

        async function createNewChat() {
             if (!currentUser) { displayError(getText('errorLogin')); return; }
             setLoadingState(true, getText('sending')); // Use 'sending' or a specific 'creating' text
             const newChatRef = db.collection('chats').doc();
             const timestamp = firebase.firestore.FieldValue.serverTimestamp();
             try {
                 await newChatRef.set({
                     userId: currentUser.uid,
                     title: getText(NEW_CHAT_KEY), // Use translated key
                     createdAt: timestamp,
                     lastUpdated: timestamp
                 });
                 console.log("New chat document created:", newChatRef.id);
                 // The listener will pick this up and switch to it
             } catch (error) {
                 console.error("Error creating new chat:", error);
                 displayError(getText('errorSend')); // Generic error
             } finally {
                 setLoadingState(false);
                 userInput.focus();
             }
        }

        function handleChatListClick(event) {
            const target = event.target;

            if (target.classList.contains('delete-chat-button')) {
                event.stopPropagation();
                const chatId = target.dataset.id;
                const chatItem = target.closest('.chat-list-item');
                const chatTitle = chatItem?.textContent.replace(DELETE_ICON, '').trim() || getText(NEW_CHAT_KEY);
                if (chatId) {
                    confirmAndDeleteChat(chatId, chatTitle);
                }
                return;
            }

            const item = target.closest('.chat-list-item');
            const clickedId = item?.dataset?.id;
            if (clickedId && clickedId !== activeChatId) {
                switchChat(clickedId);
            }
        }

        function confirmAndDeleteChat(chatId, chatTitle) {
             if (!currentUser || !chatId) return;
             if (confirm(getText('confirmDelete', { chatTitle: chatTitle }))) {
                 deleteChatFromFirestore(chatId);
             }
        }

        async function deleteChatFromFirestore(chatId) {
             if (!currentUser || !chatId) return;
             // Ensure Security Rules allow deletion:
             // match /chats/{chatId} { allow delete: if request.auth.uid == resource.data.userId; }
             // match /chats/{chatId}/messages/{messageId} { allow delete: if get(/databases/$(database)/documents/chats/$(chatId)).data.userId == request.auth.uid; }

             isDeletingChat = true;
             setLoadingState(true, getText('deletingChat'));

             const chatDocRef = db.collection('chats').doc(chatId);
             const messagesRef = chatDocRef.collection('messages');

             try {
                 // 1. Delete messages subcollection (batched)
                 const messagesSnapshot = await messagesRef.get();
                 if (!messagesSnapshot.empty) {
                     const batch = db.batch();
                     messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); });
                     await batch.commit();
                     console.log(`${messagesSnapshot.size} messages deleted for chat ${chatId}`);
                 }

                 // 2. Delete chat document
                 await chatDocRef.delete();
                 console.log(`Chat document successfully deleted: ${chatId}`);

                 // 3. Handle UI if active chat was deleted
                 if (activeChatId === chatId) {
                     activeChatId = null;
                     currentChatHistory = [];
                     if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                     chatArea.innerHTML = ''; // Immediately clear chat area
                     renderGreetingOrLoginPrompt(); // Show default prompt
                 }
                 // The chat list listener (once isDeletingChat=false) will handle selecting the next chat if available.

             } catch (error) {
                 console.error(`Error deleting chat ${chatId}:`, error);
                 displayError(getText('errorDeletingChat'));
             } finally {
                 isDeletingChat = false;
                 setLoadingState(false);
             }
        }

        function switchChat(chatId) {
            if (!currentUser || !chatId || chatId === activeChatId) return;
            activeChatId = chatId;
            highlightActiveChatInSidebar();
            loadAndListenForActiveChat(chatId);
            userInput.focus();
            userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false;
            updateUIText(); // Update placeholder etc.
        }

        function loadAndListenForActiveChat(chatId) {
             if (!currentUser || !chatId) return;
             if (activeChatListener) { activeChatListener(); activeChatListener = null; }
             highlightActiveChatInSidebar(); // Ensure it's highlighted

             const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
             chatArea.innerHTML = ''; // Clear previous chat
             currentChatHistory = []; // Reset history for API context
             const loadingMsg = displayMessage(getText('loadingChat'), 'ai', ['thinking']);

             activeChatListener = messagesRef.onSnapshot(snapshot => {
                 console.log(getText('chatMessagesSnapshot', { chatId: chatId, count: snapshot.size }));
                 removeMessageElement(loadingMsg);
                 chatArea.innerHTML = ''; // Clear again before rendering
                 currentChatHistory = []; // Reset context history before repopulating

                 if (snapshot.empty) {
                     console.log(getText('chatIsEmpty'));
                     // Don't necessarily show the greeting here, maybe just an empty state?
                     // Or let the user start typing.
                 } else {
                     snapshot.forEach(doc => {
                         const msgData = doc.data();
                         const text = msgData.text || "";
                         const role = msgData.role || "model"; // 'user' or 'model'

                         // Add to API context history
                         currentChatHistory.push({
                             role: role === 'user' ? 'user' : 'model',
                             parts: [{ text: text }]
                         });

                         // Display the message
                         // Pass full msgData to check for mcqData later if needed, though we save directly now
                         displayMessage(text, role, [], null, msgData);
                     });
                 }
                  // If after loading messages, the chat area is still empty (e.g., only thinking message was there)
                  // show the greeting if appropriate (though usually snapshot.empty handles this)
                  if (!chatArea.querySelector('.message') && currentUser) {
                      renderGreetingOrLoginPrompt();
                  }
                 scrollToBottom(true);

             }, error => {
                 console.error(getText('errorListeningMessages', { chatId: chatId }), error);
                 displayError(getText('errorLoadingMessages'));
                 removeMessageElement(loadingMsg);
                 chatArea.innerHTML = ''; // Clear on error
                 currentChatHistory = [];
             });
        }


        // --- Message Sending (Gemini API & Firestore Save) ---
        async function handleSendMessage() {
            const txt = userInput.value.trim();
            if (!API_KEY) { displayError(getText('errorApiKey')); return; }
            if (!currentUser) { displayError(getText('errorLogin')); return; }
            if (!activeChatId) { displayError(getText('errorSelectChat')); return; }
            if (!txt || sendButton.disabled) return;

            const isMCQRequest = mcqModeCheckbox.checked;
            setLoadingState(true, getText('sending'));
            const userMessageText = txt; // Keep original text for display/history

            userInput.value = ''; autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false; // Reset checkbox
            updateUIText(); // Update placeholder

            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

             // --- Check if it's the first user message in this chat (for title generation) ---
             let isFirstUserMessageInNewChat = false;
             try {
                 const chatSnap = await chatDocRef.get();
                 // Check if title is the default 'untitled' key's translation
                 if (chatSnap.exists && chatSnap.data().title === getText(NEW_CHAT_KEY)) {
                     const messagesSnap = await messagesColRef.limit(1).get();
                     if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; }
                 }
             } catch(err) { console.error(getText('errorCheckingFirstMsg'), err); }
             // --- End Check ---


            // 1. Save User Message to Firestore (before API call)
            // The listener will automatically display it.
             const userMsgData = { role: "user", text: userMessageText, timestamp: timestamp };
            try {
                const userMsgRef = await messagesColRef.add(userMsgData);
                await chatDocRef.update({ lastUpdated: timestamp });
                console.log(getText('savingUserMsg'));

                 // --- Automatic Title Update Logic (moved here) ---
                 if (isFirstUserMessageInNewChat) {
                     console.log(getText('firstMsgCheck'));
                     setLoadingState(true, getText('generatingTitle')); // Show status
                     // Use a simpler title generation for now
                     const generatedTitle = generateChatTitle(userMessageText);
                     if (generatedTitle !== getText(NEW_CHAT_KEY)) {
                         await updateActiveChatTitle(generatedTitle);
                         console.log(getText('chatTitleUpdated', { title: generatedTitle }));
                     }
                      setLoadingState(true, getText('sending')); // Revert status back
                 }
                 // --- End Title Update ---

            } catch(error) {
                console.error(getText('errorSaveUserMsg'), error);
                displayError(getText('errorSend'));
                setLoadingState(false); return; // Stop if user message can't be saved
            }

            // 2. Prepare for API Call
            const thinking = displayMessage(getText('thinking'), 'ai', ['thinking']);
            // Build history *from current state* just before sending
            const requestHistory = [ ...currentChatHistory ]; // History now includes the user message saved above

            let modifiedPrompt = userMessageText;
             let mcqPromptDetails = `Please provide the response strictly in JSON format containing an array of objects. Each object must have 'question' (string), 'options' (array of 4 strings, e.g., ["A) Opt1", "B) Opt2", "C) Opt3", "D) Opt4"]), and 'answer' (string, the letter corresponding to the correct option, e.g., "B"). Example: \`\`\`json\n[{"question":"Capital of France?","options":["A) Berlin","B) Paris","C) Rome","D) Madrid"],"answer":"B"}]\n\`\`\` Do not include any text before or after the JSON array. Generate based on the following topic:`;

            if (isMCQRequest) {
                modifiedPrompt = `${mcqPromptDetails}\n\n${userMessageText}`;
                 // Modify the last user message in the history for the API call
                 if (requestHistory.length > 0 && requestHistory[requestHistory.length - 1].role === 'user') {
                     requestHistory[requestHistory.length - 1].parts = [{ text: modifiedPrompt }];
                 } else {
                     // Should not happen if user message was just added, but as a fallback:
                     requestHistory.push({ role: "user", parts: [{ text: modifiedPrompt }] });
                 }
            }

            // 3. Call Gemini API
             console.warn(getText('insecureApiCall'));
            let aiResponseText = null;
            let mcqData = null;
            let saveError = null;
            let apiError = null;

            try {
                 const response = await fetch(API_URL_BASE + API_KEY, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         contents: requestHistory, // Send the history built just before the call
                         safetySettings: [ /* ... safety settings ... */
                            {category:"HARM_CATEGORY_HARASSMENT",threshold:"BLOCK_MEDIUM_AND_ABOVE"},
                            {category:"HARM_CATEGORY_HATE_SPEECH",threshold:"BLOCK_MEDIUM_AND_ABOVE"},
                            {category:"HARM_CATEGORY_SEXUALLY_EXPLICIT",threshold:"BLOCK_MEDIUM_AND_ABOVE"},
                            {category:"HARM_CATEGORY_DANGEROUS_CONTENT",threshold:"BLOCK_MEDIUM_AND_ABOVE"}
                         ]
                    }),
                });

                removeMessageElement(thinking); // Remove thinking message

                if (!response.ok) {
                    let errData = { message: `API Error (${response.status})` };
                    try { errData = (await response.json()).error || errData; } catch {}
                    apiError = errData.message || getText('errorApiGeneric');
                    aiResponseText = `Error: ${apiError}`; // Set text for saving
                     console.error("API Error:", errData);
                     if(response.status===400 && apiError.toLowerCase().includes('api key not valid')){
                        localStorage.removeItem(STORAGE_KEY_API_KEY); API_KEY='';
                        apiError = getText('errorApiKeyInvalid'); // More specific error
                        aiResponseText = `Error: ${apiError}`;
                     }
                     displayError(apiError); // Display specific or generic API error
                } else {
                    const data = await response.json();
                    if (data.promptFeedback?.blockReason) {
                        aiResponseText = getText('responseBlocked', { reason: data.promptFeedback.blockReason });
                        displayMessage(aiResponseText, 'ai', ['error-message']); // Display block reason as an error
                    } else if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        aiResponseText = data.candidates[0].content.parts[0].text;

                        if (isMCQRequest) {
                             // Attempt to parse MCQs
                            try {
                                const jsonMatch = aiResponseText.match(/```json\s*([\s\S]*?)\s*```/);
                                const jsonString = jsonMatch ? jsonMatch[1].trim() : aiResponseText.trim();

                                if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                    const parsedMCQs = JSON.parse(jsonString);
                                    // Validate structure
                                     if (Array.isArray(parsedMCQs) && parsedMCQs.length > 0 && parsedMCQs.every(q => q.question && Array.isArray(q.options) && q.options.length === 4 && q.answer && typeof q.answer === 'string' && ['A','B','C','D'].includes(q.answer.toUpperCase()))) {
                                        mcqData = parsedMCQs; // Store valid MCQ data
                                        console.log(getText('mcqsParsedSuccess'), mcqData);
                                        // Don't display MCQs here, save them instead.
                                        // Change the aiResponseText to an informational message for the chat.
                                         aiResponseText = getText('mcqCreated', { testsPageUrl: TESTS_PAGE_URL });
                                         // Display this info message in the chat immediately
                                         displayMessage(aiResponseText, 'ai', ['info-message']);
                                    } else {
                                         console.warn(getText('errorMCQValidation'));
                                         // Keep original AI text if validation fails, maybe add a note
                                         aiResponseText += `\n\n(${getText('errorMCQValidation')})`;
                                         displayMessage(aiResponseText, 'ai'); // Show the original response with error note
                                     }
                                } else {
                                    console.warn(getText('errorMCQFormat'));
                                     // Keep original AI text if not JSON array
                                     aiResponseText += `\n\n(${getText('errorMCQFormat')})`;
                                     displayMessage(aiResponseText, 'ai');
                                }
                            } catch (parseError) {
                                console.error(getText('errorMCQParse'), parseError);
                                // Keep original AI text on parse error
                                aiResponseText += `\n\n(${getText('errorMCQParse')})`;
                                displayMessage(aiResponseText, 'ai');
                            }
                        } else {
                            // Normal response, display it (listener will pick it up after saving)
                             console.log(getText('normalAiResponse'));
                             // displayMessage(aiResponseText, 'ai'); // Let the listener handle display after save
                        }
                    } else {
                         aiResponseText = getText('emptyResponse'); // Handle empty but successful response
                         displayMessage(aiResponseText, 'ai');
                    }
                }
            } catch (error) { // Network or other fetch errors
                removeMessageElement(thinking);
                apiError = error.message || getText('errorFetch');
                aiResponseText = `Error: ${apiError}`;
                console.error("Fetch/Processing Error:", error);
                displayError(apiError);
                saveError = apiError; // Mark save as potentially problematic
            }

            // 4. Save AI Response (or Error) & Test Definition to Firestore
            if (aiResponseText) {
                 // If MCQs were generated and parsed successfully, save to /tests collection
                 let testDefId = null;
                 if (mcqData) {
                     setLoadingState(true, getText('savingTestDef'));
                     const testDef = {
                         userId: currentUser.uid,
                         title: generateChatTitle(userMessageText) + " (MCQ)", // Generate title from user prompt
                         questions: mcqData,
                         createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                         sourceChatId: activeChatId // Link back to the chat
                     };
                     try {
                         const testRef = await db.collection('tests').add(testDef);
                         testDefId = testRef.id;
                         console.log(getText('savingTestDefSuccess', {testId: testDefId}));
                         // The aiResponseText already contains the link message for the user
                     } catch (err) {
                         console.error(getText('errorMCQSave'), err);
                         // Display an error IN ADDITION to the info message already shown
                         displayError(getText('errorMCQSave'));
                         saveError = getText('errorMCQSave'); // Mark save error
                     }
                     setLoadingState(false); // Reset loading state after test save attempt
                 }

                 // Save the AI message (info message or actual response/error) to the chat messages
                 const aiMsgData = {
                     role: "model",
                     text: aiResponseText, // This is either the normal response, block reason, error, or the MCQ created message
                     timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                     // Optionally store testDefId if created
                     ...(testDefId && { createdTestId: testDefId })
                 };

                 try {
                     if (!saveError) { // Only try saving AI msg if no major error occurred before
                         await messagesColRef.add(aiMsgData);
                         await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                         console.log(getText('savingAiMsg'));
                         // The listener will now display the saved AI message if it wasn't displayed manually (like the info message was)
                     }
                 } catch (error) {
                     console.error(getText('errorSaveAiMsg'), error);
                     displayError(getText('errorSaveAiMsg'));
                 }
            }

            // 5. Finalize
            setLoadingState(false);
            userInput.focus();
            // Listener should handle displaying the final AI message from Firestore
        }

        // --- Helper function to generate a simple title ---
        function generateChatTitle(text) {
             if (!text) return getText(NEW_CHAT_KEY);
             const words = text.split(/\s+/);
             // Limit title length (e.g., 5 words or 35 chars)
             let title = words.slice(0, 5).join(' ');
             if (title.length > 35) {
                 title = title.substring(0, 32) + '...';
             }
             // Remove trailing punctuation if any
             title = title.replace(/[.,!?;:]$/, '');
             return title || getText(NEW_CHAT_KEY); // Fallback if result is empty
        }


        // --- Update Firestore Chat Title ---
        async function updateActiveChatTitle(newTitle) {
            if (!currentUser || !activeChatId || !newTitle || newTitle === getText(NEW_CHAT_KEY)) { return; }
            const chatDocRef = db.collection('chats').doc(activeChatId);
            try {
                await chatDocRef.update({ title: newTitle });
                // Listener will update sidebar
            } catch (error) {
                console.error(getText('errorUpdatingTitle'), error);
            }
        }


        // --- UI & Message Display Functions ---
        function autoGrowTextarea() { userInput.style.height = 'auto'; userInput.style.height = (userInput.scrollHeight) + 'px'; }
        function handleInputKeydown(event) { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); handleSendMessage(); } }
        function handleSuggestionClick(event) { if (event.target.classList.contains('suggestion-chip')) { userInput.value = event.target.dataset.prompt || ''; autoGrowTextarea(); userInput.focus(); } }

        function displayError(text) {
            // Avoid displaying duplicate errors rapidly
            const lastMsg = chatArea.lastElementChild;
            if (lastMsg && lastMsg.classList.contains('error-message') && lastMsg.textContent.includes(text)) {
                return;
            }
            displayMessage(` பிழை: ${text}`, 'ai', ['error-message']); // Prefix with "பிழை:"
             scrollToBottom();
        }

        function scrollToBottom(immediate = false) { chatArea.scrollTo({ top: chatArea.scrollHeight, behavior: immediate ? 'auto' : 'smooth' }); }
        function removeMessageElement(element) { if (element?.parentNode === chatArea) chatArea.removeChild(element); }

        function setLoadingState(isLoading, message = getText('thinking')) {
            const isDisabled = isLoading || !currentUser || (!activeChatId && !isDeletingChat);
            const inputDisabled = isLoading || !currentUser;

            userInput.disabled = inputDisabled;
            sendButton.disabled = isDisabled;
            mcqModeCheckbox.disabled = isDisabled;

            if (isLoading) { userInput.placeholder = message; }
            else if (!currentUser) { userInput.placeholder = getText('loginToStart'); }
            else if (!activeChatId && !isDeletingChat) { userInput.placeholder = getText('selectOrCreateChat'); }
            else if (!activeChatId && isDeletingChat) { userInput.placeholder = getText('loadingChat'); }
            else { userInput.placeholder = mcqModeCheckbox.checked ? getText('enterQuestionMCQ') : getText('enterQuestion'); }

            startChatButton.disabled = isLoading || !currentUser;
            gotoTestsButton.disabled = isLoading || !currentUser; // Also disable tests button during load/logout
        }

         function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
             const element = document.createElement('div');
             element.classList.add('message', `${sender}-message`, ...cssClasses);

             // Basic Markdown-like formatting + HTML Escaping
             // IMPORTANT: This is basic. For robust rendering, use a library like Marked.js or sanitize carefully.
             let formattedText = text
                 .replace(/&/g, "&amp;") // Escape basic HTML first
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                 .replace(/\*(.*?)\*/g, '<em>$1</em>')     // Italics
                 // Basic Code block - careful with complex nesting or languages
                 .replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code}</code></pre>`)
                 // Inline code
                 .replace(/`([^`]+)`/g, `<code>$1</code>`)
                 // Basic link detection (very simple) - needs improvement for reliability
                 .replace(/(?<!href="|src=")(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank">$1</a>')
                 .replace(/\n/g, '<br>'); // Newlines

             // Allow specific HTML for info messages (like the link to tests page)
             if (cssClasses.includes('info-message')) {
                 // Allow 'a' tags within info messages - This is a simplification!
                 // A proper sanitizer is better.
                 formattedText = formattedText.replace(/&lt;a href="(.*?)" target="_blank"&gt;(.*?)&lt;\/a&gt;/g, '<a href="$1" target="_blank">$2</a>');
             }

              element.innerHTML = formattedText;

             // Handle MathJax rendering
             if (text.includes('$') || text.includes('\\(') || text.includes('\\[')) {
                 try {
                     if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                         // Use a timeout to ensure DOM is updated before typesetting
                         setTimeout(() => {
                             MathJax.typesetPromise([element]).catch(err => console.error('MathJax typeset error:', err));
                         }, 0);
                     }
                 } catch (e) {
                     console.error("MathJax call failed:", e);
                 }
             }

             if (appendHtml) { // This was for the old "Start Test" button, might remove
                 const tempDiv = document.createElement('div');
                 tempDiv.innerHTML = appendHtml;
                 while (tempDiv.firstChild) {
                     element.appendChild(tempDiv.firstChild);
                 }
             }

             chatArea.appendChild(element);
              // Scroll only if the user isn't scrolled up significantly
              if (chatArea.scrollHeight - chatArea.scrollTop < chatArea.clientHeight + 150) {
                   scrollToBottom();
              }
             return element;
         }

    </script>

</body>
</html>
