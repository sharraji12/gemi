<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat + Mock Test (v9.2 - Image Upload & Fixes)</title> <!-- Version Updated -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- Removed Firebase Storage import for now as we use base64 -->
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <style>
        /* --- Styles (v9.2 - Image Upload & Fixes Included) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text); }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* --- Layout & Structure --- */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; /* Initially hidden until login */ }

        /* --- Sidebar Elements --- */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         /* ... (rest of sidebar styles are the same) ... */
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; /* Space for icons */ }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        /* --- Styles for Edit/Delete Test Icons --- */
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; } /* Container for input + buttons */
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* --- Chat Area Elements --- */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; }
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        /* --- Styles for Embedded Images & Videos --- */
        .message img.chat-image, .message img.uploaded-image {
            max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; /* Ensure it takes its own line */
        }
        /* Style specifically uploaded images maybe slightly differently if needed */
        .message img.uploaded-image { border: 1px solid var(--border-color); }
        .message .youtube-embed-container { margin-top: 10px; }
        .message iframe.chat-video { max-width: 100%; aspect-ratio: 16 / 9; border: none; border-radius: 8px; }

        /* --- Input Area Elements --- */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        /* --- NEW: Image Upload Button Style --- */
        #image-upload-button {
            background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; /* Make icon bigger */ padding: 0 8px; margin-right: 5px; /* Space between icon and textarea */ line-height: 1; align-self: center; /* Center vertically */ transition: color 0.2s ease;
        }
        #image-upload-button:hover { color: var(--text-primary); }
        #image-upload-button:disabled { opacity: 0.5; cursor: not-allowed; }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* --- NEW: Image Preview Styles --- */
        #image-preview-container {
            margin-bottom: 10px; /* Space below preview, above input box */
            padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: flex; align-items: center; gap: 10px; display: none; /* Hidden by default */
        }
        #image-preview-container img {
            max-height: 50px; /* Limit preview height */ max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover;
        }
        #image-preview-info {
            font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1;
        }
        #remove-image-button {
            background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease;
        }
        #remove-image-button:hover { color: var(--remove-btn-hover-color); }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* --- Mock Test View Styles --- */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; } /* Align items horizontally */
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle {
            margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease;
        }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- Review View Styles --- */
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; } /* Allow toggle button next to it */
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* --- Responsive Design (Mobile) --- */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .main-container { }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            /* ... (rest of mobile styles are the same) ... */
            #image-upload-button { font-size: 1.3em; padding: 0 6px; }
            #image-preview-container { padding: 6px; gap: 8px; }
            #image-preview-container img { max-height: 40px; }
            #image-preview-info { font-size: 0.8em; }
            #remove-image-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
        }

    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <div class="sidebar">
            <div class="sidebar-header">Gemini Chat</div>
            <!-- Sidebar content remains the same -->
            <!-- == "All Tests" Section == -->
            <div id="all-tests-section">
                <div class="sidebar-section-title">All Tests</div>
                <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                <div class="all-tests-list" id="all-tests-list">
                     <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                </div>
            </div>
            <!-- == End "All Tests" Section == -->

            <!-- Existing sections wrapped -->
            <div class="sidebar-section">
                <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                     Start new chat
                </button>
                <div class="sidebar-section-title">Chats</div>
                <div class="chat-list" id="chat-list">
                     <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                </div>
            </div>

            <div class="sidebar-footer">
                 <div class="sidebar-controls">
                     <div class="text-size-controls">
                         <span>Text Size</span>
                         <div class="text-size-buttons">
                             <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                     </div>
                     <div class="theme-toggle">
                         <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                 </div>
                  <div id="auth-controls">
                      <button id="login-google-btn">Login with Google</button>
                      <button id="logout-btn" style="display: none;">Logout</button>
                  </div>
                  <div class="account-info">
                      <div class="account-avatar" id="account-avatar">?</div>
                      <div class="account-details">
                          <div class="account-email" id="account-email">Not logged in</div>
                          <div class="account-plan" id="account-plan"></div>
                      </div>
                  </div>
            </div>
        </div>

        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Chat messages will be loaded here -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="5 questions about US History">5 Qs US History (Check MCQ)</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Explain $\lim_{x\to 0} \frac{\sin x}{x} = 1$">Limit sin(x)/x ?</button>
                     </div>
                    <!-- NEW: Image Preview Container -->
                    <div id="image-preview-container">
                        <img id="preview-image" src="#" alt="Image preview" />
                        <span id="image-preview-info">filename.jpg</span>
                        <button id="remove-image-button" title="Remove image">&times;</button>
                    </div>
                    <div class="input-box">
                         <!-- Hidden file input -->
                         <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
                         <!-- Upload button -->
                         <button id="image-upload-button" title="Upload image" disabled>📎</button>
                         <textarea id="user-input" placeholder="Enter prompt, paste URL, or click 📎 to upload image" rows="1"></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Check to generate MCQs based on your prompt"> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View remains the same -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div> <!-- Wrapper for summary and toggle -->
                         <div class="review-summary" id="review-summary"></div>
                         <button id="review-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em; vertical-align: middle;">தமிழ்</button>
                     </div>
                     <div class="review-filters" id="review-filters" style="display: none;">
                         <button data-filter="all" class="active-filter">All</button>
                         <button data-filter="incorrect">Incorrect</button>
                         <button data-filter="skipped">Skipped</button>
                     </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer">
                     <button id="save-review-btn">Save Review</button>
                     <button id="exit-review-btn">Back</button>
                 </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View remains the same -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
                <button id="test-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em;">தமிழ்</button>
            </div>
         </div>
         <div class="test-content">
            <div class="test-question-container">
                <div class="test-question-number" id="test-question-number"></div>
                <div class="test-question" id="test-question"></div>
                <div class="test-options" id="test-options"></div>
            </div>
         </div>
         <div class="test-navigation">
            <button id="prev-question-btn" disabled>Previous</button>
            <button id="next-question-btn">Next</button>
            <button id="submit-test-btn">Submit Test</button>
         </div>
    </div>


    <script>
        // --- Firebase Config ---
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!! பாதுகாப்பு எச்சரிக்கை / SECURITY WARNING !!!
        // This firebaseConfig (especially apiKey) is insecure. Replace with your own key
        // and consider using Cloud Functions to protect it in production.
        // இந்த firebaseConfig (குறிப்பாக apiKey) பாதுகாப்பற்றது. உங்கள் சொந்த key-ஐப் பயன்படுத்தவும்
        // மற்றும் production-ல் பாதுகாக்க Cloud Functions பயன்படுத்துவதைப் பரிசீலிக்கவும்.
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- REPLACE WITH YOUR KEY
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();
        // const storage = firebase.storage(); // Uncomment if using Firebase Storage later

        // --- DOM Elements ---
        // ... (all previous DOM element variables are the same) ...
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const previewImage = document.getElementById('preview-image');
        const previewInfo = document.getElementById('image-preview-info');
        const removeImageButton = document.getElementById('remove-image-button');
        // ... (rest of DOM element variables are the same) ...
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        // Auth buttons
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const testLanguageToggle = document.getElementById('test-language-toggle');
        // Review elements
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        const reviewLanguageToggle = document.getElementById('review-language-toggle');

        // --- Config & Constants ---
        // Use a model that explicitly supports multimodal input (image + text) like 1.5 Pro
        // const MODEL_NAME = "gemini-1.5-pro-latest"; // Recommended for multimodal
        const MODEL_NAME="gemini-2.5-pro-exp-03-25"; // Keep using experimental if preferred, check its capabilities
        const API_URL_BASE=`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=`;
        const STORAGE_KEY_API_KEY='geminiApiKey_insecureDemo';
        const NEW_CHAT_TITLE="(New Chat)";
        const TEXT_SIZE_STEP=0.1;
        const MIN_TEXT_SIZE_MULTIPLIER=0.7;
        const MAX_TEXT_SIZE_MULTIPLIER=1.5;
        const LIGHT_THEME_ICON='☀️';
        const DARK_THEME_ICON='🌙';
        const DELETE_ICON = '×';
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        // Updated imageUrlRegex to be less aggressive inside potential HTML attributes
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp))/gi;
        const MAX_IMAGE_SIZE_MB = 4; // Limit upload size (adjust as needed)

        // --- State Variables ---
        let API_KEY='';
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory=[];
        let currentTextSizeMultiplier=1.0;
        let currentTheme='light';
        let isTestMode=false;
        let isReviewMode=false;
        let currentTestMCQs=[];
        let currentQuestionIndex=0;
        let userAnswers=[];
        let testStartTime=null;
        let testTimerInterval=null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null;
        let isDeletingChat = false;
        let allSavedTestsData = [];
        let currentTestLanguage = 'en';
        let currentReviewLanguage = 'en';
        // NEW: State for selected image
        let selectedImageData = {
            file: null, // The File object
            base64: null, // The base64 data URL string
            mimeType: null // e.g., "image/jpeg"
        };

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        // ... (most previous listeners are the same) ...
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        // Test listeners
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        testLanguageToggle.addEventListener('click', toggleTestLanguage);
        // Review listeners
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick); // Also handles image clicks now
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        reviewLanguageToggle.addEventListener('click', toggleReviewLanguage);
        // Auth listeners
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // NEW: Image Upload Listeners
        imageUploadButton.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        removeImageButton.addEventListener('click', removeSelectedImage);


        // --- Initialization Functions ---
        async function initializeApp() { /* ... (same as before) ... */
            loadGeminiApiKey();
            fbAuth.onAuthStateChanged(handleAuthStateChange);
            switchView('chat');
            userInput.focus();
        }

        function loadGeminiApiKey() { /* ... (same as before) ... */
             console.warn("!!! SECURITY WARNING / பாதுகாப்பு எச்சரிக்கை !!! Gemini API Key is stored in localStorage. This is highly insecure and only for demonstration. Use a server-side solution (like Cloud Functions) to protect your key in production. / Gemini API Key localStorage-ல் சேமிக்கப்படுகிறது. இது மிகவும் பாதுகாப்பற்றது மற்றும் டெமோவுக்கு மட்டுமே. Production-ல் உங்கள் key-ஐப் பாதுகாக்க server-side solution-ஐ (Cloud Functions போன்றவை) பயன்படுத்தவும்.");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(API_KEY){
                 console.log("Loaded insecure API Key from localStorage.");
             }
             else {
                 API_KEY=prompt("--- INSECURE DEMO / பாதுகாப்பற்ற டெமோ ---\nPlease enter your Gemini API Key.\nIt will be stored *insecurely* in your browser's localStorage.\nDo NOT use this method in production!\n\nஉங்கள் Gemini API Key-ஐ உள்ளிடவும்.\nஇது உங்கள் உலாவியின் localStorage-ல் *பாதுகாப்பற்ற முறையில்* சேமிக்கப்படும்.\nProduction-ல் இந்த முறையைப் பயன்படுத்த வேண்டாம்!");
                 if(API_KEY){
                     localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY);
                     console.log("Saved insecure API Key to localStorage.");
                 }
                 else {
                     displayError("Gemini API Key is required for this demo. Reload the page to enter it. / இந்த டெமோவிற்கு Gemini API Key தேவை. அதை உள்ளிட பக்கத்தை மீண்டும் ஏற்றவும்.");
                     setLoadingState(true, "API Key Missing");
                 }
             }
             setLoadingState(!API_KEY);
        }

        // --- Authentication Functions ---
        async function signInWithGoogle() { /* ... (same as before) ... */
             const provider = new firebase.auth.GoogleAuthProvider();
             try {
                 setLoadingState(true, "Logging in...");
                 await fbAuth.signInWithPopup(provider);
             } catch (error) {
                 console.error("Google Sign-In Error:", error);
                 displayError(`Login failed: ${error.message || 'Unknown error'}`);
                 setLoadingState(false);
             }
         }
        async function signOut() { /* ... (same as before) ... */
             try {
                 setLoadingState(true, "Logging out...");
                 await fbAuth.signOut();
             } catch (error) {
                 console.error("Sign Out Error:", error);
                 displayError(`Logout failed: ${error.message || 'Unknown error'}`);
                 setLoadingState(false);
             }
         }

        function handleAuthStateChange(user) { /* ... (Updated to disable upload button) ... */
            // Cleanup previous state
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            if (chatListListener) { chatListListener(); chatListListener = null; }
            if (testListListener) { testListListener(); testListListener = null; }

            chatArea.innerHTML = '';
            chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>';
            allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>';
            allTestsSection.classList.remove('visible');
            testSearchInput.value = '';
            testSearchInput.disabled = true;
            activeChatId = null;
            currentChatHistory = [];
            isDeletingChat = false;
            allSavedTestsData = [];
            removeSelectedImage(); // Clear image preview on logout/login

            if (user) {
                // User is logged IN
                currentUser = user;
                console.log("User logged in:", currentUser.uid, currentUser.displayName || currentUser.email);

                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User"; // Placeholder

                // Enable controls
                startChatButton.disabled = false;
                decreaseTextBtn.disabled = false;
                increaseTextBtn.disabled = false;
                themeToggleButton.disabled = false;
                testSearchInput.disabled = false;
                userInput.disabled = false;
                imageUploadButton.disabled = false; // Enable upload button
                sendButton.disabled = true; // Disabled until a chat is selected/created
                mcqModeCheckbox.disabled = true; // Disabled until a chat is selected/created
                userInput.placeholder = "Select or create a chat";
                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                allTestsSection.classList.add('visible');


                loadUserSettings(currentUser.uid);
                loadAndListenForChats(currentUser.uid);
                loadAndListenForTests(currentUser.uid);

                setLoadingState(false);

            } else {
                // User is logged OUT
                currentUser = null;
                console.log("User logged out");

                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in";
                accountAvatar.textContent = '?';
                accountPlan.textContent = "";

                // Disable controls
                startChatButton.disabled = true;
                decreaseTextBtn.disabled = true;
                increaseTextBtn.disabled = true;
                themeToggleButton.disabled = true;
                testSearchInput.disabled = true;
                userInput.disabled = true;
                imageUploadButton.disabled = true; // Disable upload button
                sendButton.disabled = true;
                mcqModeCheckbox.disabled = true;
                userInput.placeholder = "Please log in";
                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';
                allTestsSection.classList.remove('visible');

                renderGreetingOrLoginPrompt();

                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();

                setLoadingState(false);
            }
        }

        function renderGreetingOrLoginPrompt() { /* ... (same as before) ... */
             chatArea.innerHTML = '';
             const greetingElement = document.createElement('div');
             greetingElement.classList.add('greeting');
             if (currentUser) {
                  greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`;
                  chatArea.appendChild(greetingElement);
                  if (!activeChatId) {
                      displayMessage("Select a chat from the sidebar or start a new one.", 'ai');
                  }
             } else {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`;
                 chatArea.appendChild(greetingElement);
                 displayMessage("Please log in using the Google button in the sidebar to start chatting or view your history.", 'ai');
             }
             scrollToBottom(true);
         }

        // --- Settings (Theme/Text Size) ---
        // ... (loadUserSettings, saveUserSettings, applyTheme, toggleTheme, applyTextSize, adjustTextSize remain the same) ...
        async function loadUserSettings(userId) { /* ... (same as before) ... */
             const userDocRef = db.collection('users').doc(userId);
            try {
                const docSnap = await userDocRef.get();
                if (docSnap.exists) {
                    const settings = docSnap.data();
                    currentTheme = settings.theme || 'light';
                    currentTextSizeMultiplier = settings.textSizeMultiplier || 1.0;
                    console.log("Loaded user settings:", settings);
                } else {
                    console.log("No user settings found, using defaults and saving.");
                    currentTheme = 'light';
                    currentTextSizeMultiplier = 1.0;
                    await saveUserSettings();
                }
            } catch (error) {
                console.error("Error loading user settings:", error);
                currentTheme = 'light';
                currentTextSizeMultiplier = 1.0;
            }
            applyTheme();
            applyTextSize();
         }
        async function saveUserSettings() { /* ... (same as before) ... */
             if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = {
                theme: currentTheme,
                textSizeMultiplier: currentTextSizeMultiplier
            };
            try {
                await userDocRef.set(settings, { merge: true });
                console.log("User settings saved:", settings);
            } catch (error) {
                console.error("Error saving user settings:", error);
            }
         }
        function applyTheme() { /* ... (same as before) ... */
             if(currentTheme==='dark'){
                document.body.classList.add('dark-theme');
                themeToggleButton.textContent=LIGHT_THEME_ICON;
                themeToggleButton.title="Switch to Light Theme";
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent=DARK_THEME_ICON;
                themeToggleButton.title="Switch to Dark Theme";
            }
         }
        function toggleTheme() { /* ... (same as before) ... */
            if (!currentUser) return;
            currentTheme = (currentTheme === 'light') ? 'dark' : 'light';
            applyTheme();
            saveUserSettings();
        }
        function applyTextSize() { /* ... (same as before) ... */
            const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`;
            document.documentElement.style.setProperty('--message-font-size', newSize);
            decreaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
            console.log("Applied text size multiplier:", currentTextSizeMultiplier);
        }
        function adjustTextSize(change) { /* ... (same as before) ... */
             if (!currentUser) return;
            let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change));
            newMultiplier = Math.round(newMultiplier * 10) / 10;
            if (newMultiplier !== currentTextSizeMultiplier) {
                currentTextSizeMultiplier = newMultiplier;
                applyTextSize();
                saveUserSettings();
            }
         }

        // --- Chat Storage & Loading (Firestore) ---
        // ... (loadAndListenForChats, renderSidebarChatList, highlightActiveChatInSidebar remain the same) ...
         function loadAndListenForChats(userId) { /* ... (same as before, handles selection/loading) ... */
            if (chatListListener) { chatListListener(); chatListListener = null; }

            const chatsRef = db.collection('chats')
                               .where('userId', '==', userId)
                               .orderBy('lastUpdated', 'desc');

            console.log(`Listening for chats for user ${userId}`);
            chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) {
                     console.log("Skipping chat list update during delete operation. isDeletingChat =", isDeletingChat);
                     return;
                 }
                console.log("Processing chat list snapshot update. isDeletingChat =", isDeletingChat);

                const chats = [];
                snapshot.forEach(doc => {
                    chats.push({ id: doc.id, ...doc.data() });
                });
                console.log("Received chat list snapshot:", chats.length, "chats");
                renderSidebarChatList(chats); // Update UI

                let chatToLoad = null;
                if (activeChatId && chats.some(c => c.id === activeChatId)) {
                    chatToLoad = activeChatId; // Keep current if it still exists
                } else if (chats.length > 0) {
                    chatToLoad = chats[0].id; // Select newest if current is gone or none was active
                    console.log("Active chat not found or was deleted, selecting newest:", chatToLoad);
                } else {
                    // No chats exist
                    console.log("No chats found for user.");
                    activeChatId = null;
                    if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    renderGreetingOrLoginPrompt(); // Show greeting/prompt
                    setLoadingState(false);
                    sendButton.disabled = true; // Ensure send is disabled
                    mcqModeCheckbox.disabled = true;
                    imageUploadButton.disabled = true; // Disable upload if no chat
                    userInput.placeholder = "Create a new chat to start";
                }

                 // Switch only if the target chat is different from the current active one
                 if (chatToLoad && chatToLoad !== activeChatId) {
                     console.log("Switching to chat:", chatToLoad);
                     switchChat(chatToLoad); // This handles loading state and focusing
                 } else if (activeChatId) {
                      // Already on the correct chat or no chat to load
                      highlightActiveChatInSidebar(); // Ensure highlight is correct
                      setLoadingState(false); // Ensure loading is off
                      // Enable send/upload if a chat is active
                      const enableButtons = !API_KEY;
                      sendButton.disabled = enableButtons;
                      mcqModeCheckbox.disabled = enableButtons;
                      imageUploadButton.disabled = enableButtons;
                 } else {
                     // No chat selected/available
                     setLoadingState(false);
                 }

            }, error => {
                console.error("Error listening for chats:", error);
                displayError("Could not load your chat list. Please check your connection or try again later.");
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);font-size:0.9em;">Error loading chats.</div>';
                setLoadingState(false);
            });
        }

        function renderSidebarChatList(chats) { /* ... (same as before - renders list items with delete button) ... */
            chatListContainer.innerHTML = '';
            if (!currentUser) {
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in.</div>';
                return;
            }
            if (chats.length === 0) {
                const infoElement = document.createElement('div');
                infoElement.textContent = "No chats yet. Start one!";
                infoElement.style.cssText = "padding:10px;color:var(--text-secondary);font-size:0.9em;";
                chatListContainer.appendChild(infoElement);
            } else {
                chats.forEach(chatData => {
                    const itemElement = document.createElement('div');
                    itemElement.classList.add('chat-list-item');

                    let title = chatData.title;
                    if (typeof title !== 'string' || !title.trim()) {
                         title = '(Untitled Chat)';
                    }
                    title = title.trim();

                    itemElement.textContent = title;
                    itemElement.dataset.id = chatData.id;
                    itemElement.title = title;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-chat-button');
                    deleteBtn.innerHTML = DELETE_ICON; // Use '×'
                    deleteBtn.title = "Delete chat";
                    deleteBtn.dataset.id = chatData.id; // Store ID on button
                    itemElement.appendChild(deleteBtn);

                    chatListContainer.appendChild(itemElement);
                });
            }
            highlightActiveChatInSidebar();
        }

        function highlightActiveChatInSidebar() { /* ... (same as before) ... */
             const items = chatListContainer.querySelectorAll('.chat-list-item');
             items.forEach(item => {
                 item.classList.toggle('active', item.dataset.id === activeChatId);
             });
        }

        // --- NEW: Image Handling Functions ---
        function handleImageFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                removeSelectedImage();
                return;
            }

            // Validate file type (allow common image types)
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'];
            if (!allowedTypes.includes(file.type)) {
                alert(`Invalid file type. Please select an image (${allowedTypes.join(', ')}). / தவறான கோப்பு வகை. ஒரு படத்தைத் தேர்ந்தெடுக்கவும் (${allowedTypes.join(', ')}).`);
                imageUploadInput.value = ''; // Reset file input
                removeSelectedImage();
                return;
            }

            // Validate file size
            const fileSizeMB = file.size / 1024 / 1024;
            if (fileSizeMB > MAX_IMAGE_SIZE_MB) {
                alert(`Image is too large (${fileSizeMB.toFixed(1)}MB). Maximum size is ${MAX_IMAGE_SIZE_MB}MB. / படம் மிகப் பெரியது (${fileSizeMB.toFixed(1)}MB). அதிகபட்ச அளவு ${MAX_IMAGE_SIZE_MB}MB.`);
                 imageUploadInput.value = ''; // Reset file input
                 removeSelectedImage();
                 return;
            }


            const reader = new FileReader();
            reader.onload = (e) => {
                selectedImageData = {
                    file: file,
                    base64: e.target.result, // This is the base64 data URL
                    mimeType: file.type
                };
                console.log("Image selected:", file.name, file.type, `(${fileSizeMB.toFixed(2)} MB)`);
                previewImage.src = e.target.result;
                previewInfo.textContent = file.name;
                imagePreviewContainer.style.display = 'flex'; // Show preview
                // Optional: Clear text input when image is selected?
                // userInput.value = '';
                // autoGrowTextarea();
            }
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                alert("Error reading the image file. / படக் கோப்பைப் படிப்பதில் பிழை.");
                removeSelectedImage();
            };
            reader.readAsDataURL(file); // Read as base64 data URL
        }

        function removeSelectedImage() {
            selectedImageData = { file: null, base64: null, mimeType: null };
            imagePreviewContainer.style.display = 'none'; // Hide preview
            previewImage.src = '#'; // Clear preview image source
            previewInfo.textContent = '';
            imageUploadInput.value = ''; // Reset the file input selection
            console.log("Selected image removed.");
        }


        // --- Chat Creation, Deletion, Switching ---
        async function createNewChat() { /* ... (Added image removal) ... */
            if (!currentUser) { displayError("Please log in to create a new chat."); return; }
            setLoadingState(true, "Creating chat...");
            removeSelectedImage(); // Clear image when starting new chat
            const newChatRef = db.collection('chats').doc();
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();

            try {
                await newChatRef.set({
                    userId: currentUser.uid,
                    title: NEW_CHAT_TITLE,
                    createdAt: timestamp,
                    lastUpdated: timestamp
                });
                console.log("New chat document created:", newChatRef.id);
                // Listener will select it
            } catch (error) {
                console.error("Error creating new chat:", error);
                displayError("Failed to create the chat. Please try again.");
                setLoadingState(false);
            }
        }

        function handleChatListClick(event) { /* ... (same as before) ... */
             const target = event.target;
             const deleteButton = target.closest('.delete-chat-button');
             if (deleteButton) {
                 event.stopPropagation();
                 const chatId = deleteButton.dataset.id;
                 const chatListItem = deleteButton.closest('.chat-list-item');
                 const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat';
                 if (chatId) {
                     confirmAndDeleteChat(chatId, chatTitle);
                 }
                 return;
             }

             const item = target.closest('.chat-list-item');
             const clickedId = item?.dataset?.id;
             if (item && clickedId && clickedId !== activeChatId) {
                 switchChat(clickedId);
             }
        }

        function confirmAndDeleteChat(chatId, chatTitle) { /* ... (same as before) ... */
            if (!currentUser || !chatId) return;
            if (confirm(`Are you sure you want to permanently delete the chat "${chatTitle}" and all its messages? This cannot be undone.`)) {
                deleteChatFromFirestore(chatId);
            } else {
                console.log(`Deletion cancelled for chat: ${chatId}`);
            }
        }

        async function deleteChatFromFirestore(chatId) { /* ... (same as before) ... */
            if (!currentUser || !chatId) {
                console.log("Delete chat aborted: Missing user or chatId.");
                return;
            }
            isDeletingChat = true;
            console.log(`[Delete Start] Deleting chat: ${chatId}. isDeletingChat = ${isDeletingChat}`);
            setLoadingState(true, "Deleting chat...");

            const chatDocRef = db.collection('chats').doc(chatId);
            const messagesRef = chatDocRef.collection('messages');

            try {
                // Delete messages
                console.log(`[Delete Progress] Fetching messages for chat ${chatId}`);
                const messagesSnapshot = await messagesRef.get();
                if (!messagesSnapshot.empty) {
                    const batch = db.batch();
                    messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); });
                    console.log(`[Delete Progress] Committing batch delete for ${messagesSnapshot.size} messages.`);
                    await batch.commit();
                    console.log(`[Delete Progress] Deleted ${messagesSnapshot.size} messages for chat ${chatId}`);
                } else {
                    console.log(`[Delete Progress] No messages found to delete for chat ${chatId}`);
                }

                // Delete chat doc
                console.log(`[Delete Progress] Deleting chat document ${chatId}`);
                await chatDocRef.delete();
                console.log(`[Delete Success] Successfully deleted chat document: ${chatId}`);

                // Reset UI if active chat was deleted
                if (activeChatId === chatId) {
                    console.log("[Delete Progress] Active chat was deleted. Resetting UI.");
                    activeChatId = null;
                    currentChatHistory = [];
                    if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    chatArea.innerHTML = '';
                    renderGreetingOrLoginPrompt();
                    userInput.placeholder = "Select or create a chat";
                    sendButton.disabled = true;
                    mcqModeCheckbox.disabled = true;
                    imageUploadButton.disabled = true; // Disable upload button
                    removeSelectedImage(); // Clear preview
                }

            } catch (error) {
                console.error(`[Delete Error] Error deleting chat ${chatId}:`, error);
                displayError(`Failed to delete the chat. Please try again.`);
                setLoadingState(false);
            } finally {
                isDeletingChat = false;
                console.log(`[Delete End] Finished delete attempt for chat ${chatId}. isDeletingChat = ${isDeletingChat}`);
            }
        }

        function switchChat(chatId) { /* ... (Added image removal) ... */
             if (!currentUser || !chatId || chatId === activeChatId) {
                 console.log("Switch chat condition not met or already active.");
                 return;
             }

             console.log("Switching to chat:", chatId);
             setLoadingState(true, "Loading chat...");
             activeChatId = chatId;
             removeSelectedImage(); // Clear image preview when switching chat

             highlightActiveChatInSidebar();

             userInput.value = '';
             autoGrowTextarea();
             mcqModeCheckbox.checked = false;
             userInput.placeholder = "Loading messages...";

             loadAndListenForActiveChat(chatId);
        }

        // --- Message Loading (Firestore) ---
        function loadAndListenForActiveChat(chatId) { /* ... (Updated placeholder) ... */
            if (!currentUser || !chatId) {
                console.log("Cannot load messages: Missing user or chatId.");
                chatArea.innerHTML = '';
                if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                renderGreetingOrLoginPrompt();
                setLoadingState(false);
                sendButton.disabled = true;
                mcqModeCheckbox.disabled = true;
                imageUploadButton.disabled = true;
                return;
            }

            if (activeChatListener) { activeChatListener(); activeChatListener = null; }

            const messagesRef = db.collection('chats').doc(chatId)
                                  .collection('messages')
                                  .orderBy('timestamp', 'asc');

            chatArea.innerHTML = '';
            const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']);
            scrollToBottom(true);

            console.log(`Listening for messages in chat ${chatId}`);
            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages");
                removeMessageElement(loadingMsg);
                chatArea.innerHTML = '';
                currentChatHistory = []; // Reset history array

                if (snapshot.empty && activeChatId === chatId) {
                    console.log("Chat is empty or newly created.");
                    const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`);
                    const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || '';
                    if (chatTitle && chatTitle !== NEW_CHAT_TITLE) {
                         displayMessage("This chat is empty. Send a message to start!", 'ai');
                    } else {
                         renderGreetingOrLoginPrompt();
                    }

                } else {
                    // Render messages
                    snapshot.forEach(doc => {
                        const msgData = doc.data();
                        const text = typeof msgData.text === 'string' ? msgData.text : "";
                        const role = msgData.role === 'user' ? 'user' : 'model';

                        // Add to local history cache (simple format for API context)
                        // Only include text part for basic history
                        currentChatHistory.push({
                             role: role,
                             parts: [{ text: text }]
                        });

                        // Display the message, passing full data
                        displayMessage(text, role, [], null, msgData);
                    });
                }
                scrollToBottom(true);
                setLoadingState(false);

                // Enable input/send/upload now that chat is loaded
                const enableButtons = !API_KEY;
                sendButton.disabled = enableButtons;
                mcqModeCheckbox.disabled = enableButtons;
                imageUploadButton.disabled = enableButtons;
                userInput.placeholder = "Enter prompt, paste URL, or click 📎 to upload image"; // Updated placeholder
                if (!isTestMode && !isReviewMode) userInput.focus();


            }, error => {
                console.error(`Error listening for messages in chat ${chatId}:`, error);
                displayError("Could not load messages for this chat. Please check your connection.");
                removeMessageElement(loadingMsg);
                chatArea.innerHTML = '';
                currentChatHistory = [];
                setLoadingState(false);
                sendButton.disabled = true;
                mcqModeCheckbox.disabled = true;
                imageUploadButton.disabled = true;
                userInput.placeholder = "Error loading chat";
            });
        }

        // --- Message Sending (Gemini API & Firestore Save) ---
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim(); // Get text input
            const imageToSend = selectedImageData.base64 ? { ...selectedImageData } : null; // Copy image data if present

            // Basic validation
            if (!API_KEY) { displayError("Gemini API Key not set."); return; }
            if (!currentUser) { displayError("Please log in first."); return; }
            if (!activeChatId) { displayError("Please select or create a chat first."); return; }
            // Require text OR an image to send
            if (!userMessageTextRaw && !imageToSend) {
                console.log("Nothing to send (no text or image).");
                return;
            }
             if (sendButton.disabled) return; // Don't send if disabled

            const isMCQRequest = mcqModeCheckbox.checked;
            setLoadingState(true, "Sending...");

            // Clear input AFTER copying values
            userInput.value = '';
            autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false;
            removeSelectedImage(); // Clear preview and selected image state

            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

            let isFirstUserMessageInNewChat = false;
            let potentialTestTitle = null;

            // --- Fix YouTube URL in Text for API ---
            let userMessageTextForAPI = userMessageTextRaw;
            const youtubeMatch = userMessageTextRaw.match(youtubeRegex);
            const youtubeVideoId = youtubeMatch ? youtubeMatch[1] : null;
            if (youtubeVideoId) {
                console.log("Detected YouTube Video ID:", youtubeVideoId);
                // Remove the YouTube URL from the text being sent to the API
                // The AI cannot process video links directly.
                 userMessageTextForAPI = userMessageTextRaw.replace(youtubeRegex, '').trim();
                 console.log("YouTube URL removed for API call. Text sent:", userMessageTextForAPI);
                 if (!userMessageTextForAPI && !imageToSend) {
                     displayError("Cannot send only a YouTube link. Please add a text prompt or image. The video will still be embedded.");
                     setLoadingState(false);
                     return;
                 }
                 // Explain the limitation
                 displayMessage("Note: I can embed the YouTube video for you to see, but I cannot analyze its content directly from the link.", 'ai');
            }

            // Prepare user message data for Firestore
            // Store the RAW text (including YT link if any) and image data
             const userMsgData = {
                 role: "user",
                 text: userMessageTextRaw, // Store original text
                 timestamp: timestamp,
                 ...(youtubeVideoId && { youtubeVideoId: youtubeVideoId }), // Store YT ID for embedding
                 ...(imageToSend && { imageData: imageToSend.base64, imageMimeType: imageToSend.mimeType }) // Store image base64 & type
                 // Note on base64 in Firestore: This is simple but not ideal for large images due to document size limits (1MB).
                 // Firebase Storage is the recommended solution for production (upload image, store URL).
             };
             console.log("Saving to Firestore:", { ...userMsgData, imageData: imageToSend ? "Base64 Data Hidden" : null }); // Avoid logging huge base64 string


             try {
                 // Check for first message for title generation
                 const chatSnap = await chatDocRef.get();
                 if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) {
                     const messagesSnap = await messagesColRef.limit(1).get();
                     if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; }
                 }

                 // Save user message
                 await messagesColRef.add(userMsgData);
                 await chatDocRef.update({ lastUpdated: timestamp });
                 console.log("User message saved to Firestore.");

                 // Generate title if first message
                 if (isFirstUserMessageInNewChat) {
                     const titleTextSource = userMessageTextRaw || (imageToSend ? "Image Upload" : NEW_CHAT_TITLE);
                     const generatedTitle = generateChatTitle(titleTextSource);
                     if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) {
                         await updateActiveChatTitle(generatedTitle);
                         console.log("Chat title updated automatically:", generatedTitle);
                     }
                 }

             } catch(error) {
                 console.error("Error saving user message or updating title:", error);
                 displayError("Failed to send message. Please check connection and try again.");
                 setLoadingState(false);
                 return;
             }

             // Display "Thinking..." message
            const thinking = displayMessage("Thinking...", 'ai', ['thinking']);
            scrollToBottom();

            // Prepare history for API call (only text parts)
            const apiHistoryForCall = currentChatHistory.map(msg => ({
                 role: msg.role,
                 parts: msg.parts.filter(part => part.text) // Only include text parts
             })).filter(msg => msg.parts.length > 0);

            // Prepare current user message parts for API
            const currentUserPartsForAPI = [];
            if (userMessageTextForAPI) { // Use the text *without* the YT URL
                currentUserPartsForAPI.push({ text: userMessageTextForAPI });
            }
            if (imageToSend) {
                 // Remove the "data:mime/type;base64," prefix from the base64 string for the API
                 const base64DataOnly = imageToSend.base64.substring(imageToSend.base64.indexOf(',') + 1);
                 currentUserPartsForAPI.push({
                    inlineData: {
                        mimeType: imageToSend.mimeType,
                        data: base64DataOnly
                    }
                });
                console.log(`Preparing image for API: ${imageToSend.mimeType}`);
            }

             // Modify prompt for MCQ request (using text part only)
             let finalUserPartsForAPI = [...currentUserPartsForAPI]; // Copy parts

             if (isMCQRequest) {
                 if (!userMessageTextForAPI) {
                      displayError("Cannot generate MCQs from only an image. Please add a text prompt describing the topic.");
                      removeMessageElement(thinking);
                      setLoadingState(false);
                      return;
                 }
                 potentialTestTitle = generateChatTitle(userMessageTextForAPI);
                 potentialTestTitle = (potentialTestTitle === NEW_CHAT_TITLE || !potentialTestTitle) ? "Generated Test" : potentialTestTitle;
                 potentialTestTitle += ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;

                 const mcqPromptText = `${userMessageTextForAPI}\n\nPlease generate multiple choice questions... (rest of your bilingual prompt)`; // Your full MCQ prompt here

                 // Replace the text part in the copied parts array
                 const textPartIndex = finalUserPartsForAPI.findIndex(part => part.text);
                 if (textPartIndex !== -1) {
                     finalUserPartsForAPI[textPartIndex] = { text: mcqPromptText };
                 } else {
                     // Should not happen if we validated earlier, but as fallback add it
                     finalUserPartsForAPI.unshift({ text: mcqPromptText });
                 }
                 console.log("MCQ mode: Modified prompt for API, potential title:", potentialTestTitle);
             }

             // Add the (potentially modified) current user message to the history for the API call
             if (finalUserPartsForAPI.length > 0) {
                  apiHistoryForCall.push({ role: "user", parts: finalUserPartsForAPI });
             } else {
                 console.warn("No valid parts to send to API.");
                 // Maybe display an error? For now, just don't call API.
                 removeMessageElement(thinking);
                 setLoadingState(false);
                 return;
             }


             console.warn("Calling Gemini API with potentially multimodal input. Check model compatibility.");
             try {
                 const response = await fetch(API_URL_BASE + API_KEY, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                         contents: apiHistoryForCall, // Send history + current message parts
                         safetySettings: [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                         ]
                     }),
                 });

                 removeMessageElement(thinking);

                 // Prepare default AI response structure
                 let aiMsgData = { role: "model", text: "Error: No valid response.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null };
                 let displayAsError = true;

                 if (!response.ok) { /* ... (Error handling same as before) ... */
                     let errorDetails = `API error (${response.status})`;
                     try { const errorJson = await response.json(); errorDetails = errorJson.error?.message || errorDetails; } catch {}
                     console.error("API Error:", response.status, errorDetails);
                     aiMsgData.text = `Error: ${errorDetails}`;
                     if (response.status === 400 && errorDetails.toLowerCase().includes('api key not valid')) {
                          localStorage.removeItem(STORAGE_KEY_API_KEY); API_KEY='';
                          aiMsgData.text += " Your API Key seems invalid and has been cleared. Reload the page to enter a new key.";
                     }
                 } else {
                     // Handle successful API response
                     const data = await response.json();
                     let rawAiText = "";
                     let blocked = false;
                     displayAsError = false;

                     // Check safety blocks
                     if (data.promptFeedback?.blockReason) { /* ... (Safety block handling same as before) ... */
                         aiMsgData.text = `Blocked: Your prompt was blocked due to safety concerns (${data.promptFeedback.blockReason}).`;
                         blocked = true; displayAsError = true; console.warn("Prompt blocked:", data.promptFeedback.blockReason);
                     } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                          aiMsgData.text = `Blocked: The response was blocked due to safety concerns.`;
                          blocked = true; displayAsError = true; console.warn("Response blocked due to safety.");
                     } else if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                         // Valid text response
                         rawAiText = data.candidates[0].content.parts[0].text;
                         aiMsgData.text = rawAiText;

                         // Parse MCQ if requested and not blocked
                         if (isMCQRequest && !blocked) { /* ... (MCQ parsing logic same as before) ... */
                             console.log("Attempting to parse BILINGUAL MCQ JSON from response...");
                              try {
                                  const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/);
                                  const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim();
                                  if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                      const mcqs = JSON.parse(jsonString);
                                      const isValidMCQArray = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q && q.question && typeof q.question.en === 'string' && typeof q.question.ta === 'string' && Array.isArray(q.options) && q.options.length === 4 && q.options.every(opt => opt && typeof opt.en === 'string' && typeof opt.ta === 'string') && typeof q.answer === 'string' && ['A','B','C','D'].includes(q.answer.toUpperCase()) && q.explanation && typeof q.explanation.en === 'string' && typeof q.explanation.ta === 'string');
                                      if (isValidMCQArray) {
                                          const summaryText = `Successfully generated ${mcqs.length} multiple choice questions...`; // Your summary text
                                          aiMsgData.text = summaryText;
                                          aiMsgData.mcqData = mcqs;
                                          aiMsgData.mcqTitle = potentialTestTitle;
                                          console.log("BILINGUAL MCQs parsed successfully:", mcqs.length);
                                          displayAsError = false;
                                      } else {
                                           console.warn("BILINGUAL MCQ JSON validation failed.");
                                           aiMsgData.text = "Received MCQ data, but format incorrect.\n\n" + rawAiText;
                                           displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null;
                                      }
                                  } else {
                                       console.warn("AI response for MCQ request didn't look like JSON array.");
                                       aiMsgData.text = "Expected MCQs in JSON format, but didn't receive it correctly.\n\n" + rawAiText;
                                       displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null;
                                  }
                              } catch (parseError) {
                                   console.error("Failed to parse MCQ JSON:", parseError);
                                   aiMsgData.text = "Error parsing the generated MCQ JSON data.\n\n" + rawAiText;
                                   displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null;
                              }
                         } // End MCQ parsing

                     } else { // No valid text content
                         console.warn("Unexpected API response format or empty content:", data);
                         // Check if maybe it's *only* an image generation or something else non-text?
                         // For now, assume error if no text part.
                         aiMsgData.text = "Sorry, I received an unexpected or empty response.";
                         displayAsError = true;
                     }
                 }

                 // Save the AI response to Firestore
                 try {
                      await messagesColRef.add(aiMsgData);
                      await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                      console.log("AI response/error saved to Firestore.");
                 } catch (saveError) {
                      console.error("Error saving AI response to Firestore:", saveError);
                      displayError(`Received response, but failed to save it: ${aiMsgData.text}`);
                 }

             } catch (fetchError) { // Network errors etc.
                 console.error("Fetch/Processing Error:", fetchError);
                 removeMessageElement(thinking);
                 const errorText = `Error communicating with the API: ${fetchError.message || "Check network connection."}`;
                 displayError(errorText);
                 // Attempt to save fetch error to history
                 try {
                     await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() });
                     await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                 } catch (saveError) { console.error("Failed to save fetch error to history:", saveError); }
             } finally {
                 setLoadingState(false); // Re-enable inputs
                 if (!isTestMode && !isReviewMode && activeChatId) {
                      userInput.focus();
                 }
             }
        } // End of handleSendMessage

        // --- Chat Title Generation/Update ---
        function generateChatTitle(sourceText) { /* ... (same as before) ... */
             if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE;
             const text = sourceText.trim();
             if (!text) return NEW_CHAT_TITLE;
             const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, '');
             return title.length > 35 ? title.substring(0, 32) + '...' : title;
        }
        async function updateActiveChatTitle(newTitle) { /* ... (same as before) ... */
              if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return;
              const finalTitle = newTitle.trim();
              const chatDocRef = db.collection('chats').doc(activeChatId);
              try {
                  await chatDocRef.update({ title: finalTitle });
                  console.log(`Chat ${activeChatId} title updated to: "${finalTitle}"`);
              } catch (error) {
                  console.error("Error updating chat title in Firestore:", error);
              }
         }

        // --- UI & Message Display Helpers ---
        function autoGrowTextarea() { /* ... (same as before) ... */ userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { /* ... (same as before) ... */ if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();handleSendMessage();} }
        function handleSuggestionClick(event) { /* ... (same as before) ... */ if(event.target.classList.contains('suggestion-chip')){userInput.value=event.target.dataset.prompt||'';autoGrowTextarea();userInput.focus();} }

        function displayError(text) { /* ... (same as before) ... */
            console.error("Displaying Error:", text);
            displayMessage(`Error: ${text}`, 'ai', ['error-message']);
            scrollToBottom();
        }
        function scrollToBottom(immediate = false) { /* ... (same as before) ... */ chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { /* ... (same as before) ... */ if(element && element.parentNode === chatArea) { chatArea.removeChild(element); } }

        function setLoadingState(isLoading, message = "Generating...") { /* ... (Updated to include upload button and placeholder) ... */
             const isDisabledOverall = isLoading || !currentUser || !API_KEY;
             const isSendDisabled = isDisabledOverall || !activeChatId;

             userInput.disabled = isDisabledOverall;
             sendButton.disabled = isSendDisabled;
             mcqModeCheckbox.disabled = isSendDisabled;
             imageUploadButton.disabled = isSendDisabled; // Disable upload button similarly

             const isControlDisabled = isLoading || !currentUser;
             startChatButton.disabled = isControlDisabled;
             testSearchInput.disabled = isControlDisabled;
             decreaseTextBtn.disabled = isControlDisabled || (currentUser && currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER);
             increaseTextBtn.disabled = isControlDisabled || (currentUser && currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER);
             themeToggleButton.disabled = isControlDisabled;

             if (isLoading) {
                 userInput.placeholder = message;
             } else if (!currentUser) {
                 userInput.placeholder = "Please log in";
             } else if (!activeChatId) {
                 userInput.placeholder = "Select or create a chat";
             } else if (!API_KEY) {
                 userInput.placeholder = "API Key missing. Reload page.";
             } else {
                 userInput.placeholder = "Enter prompt, paste URL, or click 📎 to upload image"; // Updated placeholder
             }
         }

        function switchView(viewName, cameFromTests = false) { /* ... (same as before) ... */
            console.log("Switching view to:", viewName, "Came from tests:", cameFromTests);
            chatView.classList.remove('active');
            reviewView.classList.remove('active');
            testView.classList.remove('active');
            appContainer.classList.remove('hidden');

            isTestMode = false;
            isReviewMode = false;
            cameFromAllTestsList = cameFromTests;

            saveReviewBtn.style.display = 'none';
            exitReviewBtn.style.display = 'none';

            if(viewName==='test'){
                appContainer.classList.add('hidden');
                testView.classList.add('active');
                isTestMode=true;
            } else if(viewName==='review'){
                reviewView.classList.add('active');
                isReviewMode=true;
                exitReviewBtn.style.display = 'inline-block';
                exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat";
            } else {
                chatView.classList.add('active');
                if (currentUser && activeChatId && API_KEY) {
                    userInput.focus();
                }
            }

            if (viewName !== 'test' && testTimerInterval) {
                clearInterval(testTimerInterval);
                testTimerInterval = null;
                console.log("Test timer cleared.");
            }
        }

        // Displays a message in the chat area (MODIFIED for Uploaded Image)
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses && cssClasses.length > 0) {
                messageElement.classList.add(...cssClasses);
            }

            const messageContentContainer = document.createElement('div'); // Holds text and potentially inline images

            // --- NEW: Handle Displaying Uploaded Image (if present) ---
            // Check if image data (base64) exists in the message data from Firestore
            if (messageData?.imageData) {
                console.log("Rendering uploaded image from message data.");
                const img = document.createElement('img');
                img.src = messageData.imageData; // Use base64 data URL
                img.alt = "Uploaded Image";
                img.classList.add('uploaded-image'); // Specific class for uploaded images
                img.loading = "lazy";
                messageElement.appendChild(img); // Add image BEFORE text container
            }

            // Sanitize and format text content
            const tempDiv = document.createElement('div');
            tempDiv.innerText = text || "";
            let formattedText = tempDiv.innerHTML;

             // Replace Image URLs found IN TEXT (if not an uploaded image message)
             if (!messageData?.imageData) { // Only parse URLs if no uploaded image is present
                 formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => {
                    console.log("Found image URL in text:", imgUrl);
                    return `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy">`;
                });
             }

            // Apply other formatting
             formattedText = formattedText
                .replace(/```([\s\S]*?)```/g, (match, code) => `<pre><code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>`)
                .replace(/`([^`]+)`/g, (match, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>')
                .replace(/\n/g, '<br>');

            messageContentContainer.innerHTML = formattedText;
            if (text) { // Only add the container if there's text
                messageElement.appendChild(messageContentContainer);
            }


            // Handle YouTube Video Embed (if ID exists)
            if (messageData?.youtubeVideoId) {
                console.log("Rendering YouTube video:", messageData.youtubeVideoId);
                const youtubeEmbedDiv = document.createElement('div');
                youtubeEmbedDiv.classList.add('youtube-embed-container');
                const iframe = document.createElement('iframe');
                iframe.classList.add('chat-video');
                iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`;
                iframe.title = "YouTube video player";
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share";
                iframe.allowFullscreen = true;
                iframe.loading = "lazy";
                youtubeEmbedDiv.appendChild(iframe);
                messageElement.appendChild(youtubeEmbedDiv);
            }

            // Handle MCQ Offer
            if (messageData?.role === 'model' && messageData?.mcqData && Array.isArray(messageData.mcqData) && messageData.mcqData.length > 0) {
                 displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement);
            }
            else if (appendHtml) { /* ... (Append HTML logic same) ... */
                const appendDiv = document.createElement('div');
                appendDiv.innerHTML = appendHtml;
                while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); }
            }

            chatArea.appendChild(messageElement);

             // Render MathJax
             try {
                 if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                     MathJax.typesetPromise([messageElement]).catch(err => console.error('MathJax typeset error:', err));
                 }
             } catch (e) { console.error("MathJax call failed:", e); }

            return messageElement;
        }


        // --- MCQ/Test Specific Functions ---
        // ... (handleChatAreaClick, displayMCQOffer, toggleTestLanguage, startMockTest, displayTestQuestion, handleOptionSelect, handleTestNavigation, startTestTimer, submitTest remain the same) ...
        function handleChatAreaClick(event) {
            // Handle Start Test Button click
            const startButton = event.target.closest('.start-test-button');
            if (startButton) {
                 const mcqDataString = startButton.dataset.mcq;
                 const titleFromButton = startButton.dataset.mcqTitle;
                 let mcqs = null;
                 if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed to parse MCQ data:", e); displayError("Could not start test."); return; } }
                 if (mcqs && Array.isArray(mcqs) && mcqs.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { console.error("MCQ data missing/invalid."); displayError("Could not start test."); }
                 return; // Prevent image click handling if button was clicked
            }

            // Handle click on embedded images (URL-based or Uploaded)
            const clickedImage = event.target.closest('img.chat-image, img.uploaded-image');
            if (clickedImage && clickedImage.src && !clickedImage.src.endsWith('#')) { // Ensure src is valid
                window.open(clickedImage.src, '_blank');
            }
        }
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { /* ... (same as before) ... */
             if (aiMessageElement.querySelector('.start-test-button')) return;
             const questionCount = mcqData.length;
             const button = document.createElement('button');
             button.classList.add('start-test-button');
             button.textContent = `Start Mock Test (${questionCount} Questions)`;
             button.title = mcqTitle || `Start a test with ${questionCount} questions`;
             try {
                button.dataset.mcq = JSON.stringify(mcqData);
                if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; }
             } catch (e) { console.error("Failed to stringify MCQ data for button:", e); return; }
             const buttonContainer = document.createElement('div');
             buttonContainer.style.marginTop = '10px';
             buttonContainer.appendChild(button);
             aiMessageElement.appendChild(buttonContainer);
        }
        function toggleTestLanguage() { /* ... (same as before) ... */
            currentTestLanguage = (currentTestLanguage === 'en') ? 'ta' : 'en';
            testLanguageToggle.textContent = (currentTestLanguage === 'en') ? 'தமிழ்' : 'English';
            displayTestQuestion(currentQuestionIndex);
            console.log("Switched test language to:", currentTestLanguage);
        }
        function startMockTest(mcqs, title = null) { /* ... (same as before) ... */
            if (!currentUser) { displayError("Please log in to start a test."); return; }
            if (!mcqs || mcqs.length === 0) { displayError("No questions available for this test."); if (cameFromAllTestsList) { switchView('chat'); } return; }
            console.log("Starting mock test:", mcqs.length, "questions. Title:", title);
            currentTestMCQs = mcqs;
            currentQuestionIndex = 0;
            userAnswers = new Array(mcqs.length).fill(null);
            reviewResultsCache = null;
            currentTestLanguage = 'en';
            testLanguageToggle.textContent = 'தமிழ்';
            switchView('test');
            displayTestQuestion(0);
            startTestTimer();
            const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Questions)`;
            testTitle.textContent = finalTitle;
        }
        function displayTestQuestion(index) { /* ... (same as before) ... */
            if (index < 0 || index >= currentTestMCQs.length) return;
            currentQuestionIndex = index;
            const questionData = currentTestMCQs[index];
            const lang = currentTestLanguage;
            const questionText = questionData.question?.[lang] || questionData.question?.en || "(Question missing)";
            testQuestionNumber.textContent = `Question ${index + 1}`;
            testQuestion.innerHTML = questionText;
            testOptionsContainer.innerHTML = '';
            const options = Array.isArray(questionData.options) ? questionData.options : [];
            const optionLetters = ['A', 'B', 'C', 'D'];
            options.forEach((optionObj, optionIndex) => {
                 if (optionIndex >= optionLetters.length) return;
                 const optionText = optionObj?.[lang] || optionObj?.en || '(Empty Option)';
                 const label = document.createElement('label');
                 const input = document.createElement('input');
                 input.type = 'radio';
                 input.name = `q_${index}`;
                 input.value = optionIndex;
                 input.checked = (userAnswers[index] === optionIndex);
                 input.onchange = () => handleOptionSelect(optionIndex);
                 label.appendChild(input);
                 label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`));
                 testOptionsContainer.appendChild(label);
            });
             try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err => console.error('MathJax error:', err)); } } catch(e){ console.error("MathJax call failed:", e); }
            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1);
            questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`;
        }
        function handleOptionSelect(optionIndex) { /* ... (same as before) ... */
            if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option index ${optionIndex}`); }
        }
        function handleTestNavigation(direction) { /* ... (same as before) ... */
            let newIndex = currentQuestionIndex;
            if (direction === 'prev' && currentQuestionIndex > 0) { newIndex--; }
            else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) { newIndex++; }
            if (newIndex !== currentQuestionIndex) { displayTestQuestion(newIndex); }
        }
        function startTestTimer() { /* ... (same as before) ... */
            if (testTimerInterval) clearInterval(testTimerInterval);
            testStartTime = Date.now();
            testTimer.textContent = `Time: 00:00`;
            testTimerInterval = setInterval(() => {
                const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
                const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
                testTimer.textContent = `Time: ${minutes}:${seconds}`;
            }, 1000);
        }
        function submitTest() { /* ... (same as before) ... */
            if (!confirm("Are you sure you want to submit the test?")) return;
            if (testTimerInterval) clearInterval(testTimerInterval);
            const endTime = Date.now();
            const timeTakenMs = testStartTime ? endTime - testStartTime : 0;
            console.log("Submitting test. Time (ms):", timeTakenMs);
            const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs);
            reviewResultsCache = results;
            switchView('review', false);
            displayReview(results);
        }

        // --- Review Functions ---
        // ... (toggleReviewLanguage, calculateResults, displayReview, handleReviewFilterClick, filterReviewItems, exitReview, saveTestReviewToCloud remain the same) ...
        function toggleReviewLanguage() { /* ... (same as before) ... */
            currentReviewLanguage = (currentReviewLanguage === 'en') ? 'ta' : 'en';
            reviewLanguageToggle.textContent = (currentReviewLanguage === 'en') ? 'தமிழ்' : 'English';
            if (reviewResultsCache) { displayReview(reviewResultsCache); }
            console.log("Switched review language to:", currentReviewLanguage);
        }
        function calculateResults(mcqs, answers, timeMs) { /* ... (same as before) ... */
             let correctCount = 0, incorrectCount = 0, skippedCount = 0;
             const reviewQuestions = [];
             mcqs.forEach((qData, index) => {
                 const userAnswerIndex = answers[index];
                 const options = Array.isArray(qData.options) ? qData.options : [];
                 const correctAnswerLetter = qData.answer?.trim().toUpperCase();
                 const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                 const correctAnswerTextEn = (correctAnswerIndex >= 0 && correctAnswerIndex < options.length) ? (options[correctAnswerIndex]?.en || '(Missing Correct)') : "N/A";
                 let userAnswerTextEn = "Skipped"; let status = "skipped";
                 if (userAnswerIndex !== null && userAnswerIndex >= 0 && userAnswerIndex < options.length) {
                     userAnswerTextEn = options[userAnswerIndex]?.en || '(Missing User Option)';
                     if (userAnswerIndex === correctAnswerIndex) { status = "correct"; correctCount++; } else { status = "incorrect"; incorrectCount++; }
                 } else if (userAnswerIndex !== null) { userAnswerTextEn = "Invalid Selection"; status = "incorrect"; incorrectCount++; }
                 else { skippedCount++; }
                 reviewQuestions.push({ question: qData.question?.en || '(Missing)', correctAnswer: correctAnswerTextEn, userAnswer: userAnswerTextEn, status: status, explanation: qData.explanation?.en || "No explanation." });
             });
             const totalQuestions = mcqs.length;
             const score = `${correctCount}/${totalQuestions}`;
             const timeSeconds = Math.round(timeMs / 1000);
             const minutes = Math.floor(timeSeconds / 60);
             const seconds = timeSeconds % 60;
             const timeString = `${minutes}m ${seconds}s`;
             return { questions: reviewQuestions, summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs };
        }
        function displayReview(reviewData) { /* ... (same as before) ... */
             reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none';
             if (!reviewData || !reviewData.questions || reviewData.questions.length === 0 || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No valid review data available.</span>"; reviewContent.innerHTML = "<p>Review data missing or incomplete.</p>"; saveReviewBtn.style.display = 'none'; return; }
             const expectedButtonText = (currentReviewLanguage === 'en') ? 'தமிழ்' : 'English';
             if (!reviewLanguageToggle || reviewLanguageToggle.textContent !== expectedButtonText) { currentReviewLanguage = 'en'; if (reviewLanguageToggle) reviewLanguageToggle.textContent = 'தமிழ்'; }
             const { score, correct, incorrect, skipped, timeString } = reviewData.summary;
             reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`;
             reviewTitle.textContent = reviewData.testTitle || "Test Review";
             const lang = currentReviewLanguage;
             reviewData.questions.forEach((qReviewSummary, index) => {
                 const originalQData = reviewData.originalMCQs[index];
                 if (!originalQData) { console.warn(`Original MCQ missing for review item ${index}`); /* Fallback display */ return; }
                 const questionText = originalQData.question?.[lang] || originalQData.question?.en || '(Question missing)';
                 const options = originalQData.options || [];
                 const correctAnswerLetter = originalQData.answer?.trim().toUpperCase();
                 const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                 const correctAnswerText = (correctAnswerIndex >= 0 && correctAnswerIndex < options.length) ? (options[correctAnswerIndex]?.[lang] || options[correctAnswerIndex]?.en) : "N/A";
                 let userAnswerText = qReviewSummary.userAnswer; const status = qReviewSummary.status;
                 if (status !== 'skipped' && status !== 'invalid') { const userAnswerEn = qReviewSummary.userAnswer; const userAnswerIndex = options.findIndex(opt => opt.en === userAnswerEn); if (userAnswerIndex !== -1) { userAnswerText = options[userAnswerIndex]?.[lang] || options[userAnswerIndex]?.en; } else { userAnswerText = userAnswerEn || '(Answer missing)'; } }
                 else if (status === 'skipped') { userAnswerText = (lang === 'ta') ? "தவிர்க்கப்பட்டது" : "Skipped"; }
                 else { userAnswerText = (lang === 'ta') ? "தவறான தேர்வு" : "Invalid Selection"; }
                 const explanationText = originalQData.explanation?.[lang] || originalQData.explanation?.en || "No explanation.";
                 let itemStatusClass = `status-${status}`; let answerDetailClass = `user-answer-${status}`;
                 const reviewItem = document.createElement('div'); reviewItem.classList.add('review-item', itemStatusClass); reviewItem.dataset.status = status;
                 let detailsHtml = `<span class="${answerDetailClass}">Your Answer: ${userAnswerText}</span>`;
                 if (status !== 'correct') { detailsHtml += `<br><span class="correct-answer">Correct Answer: ${correctAnswerText}</span>`; }
                 detailsHtml += `<div class="review-item-explanation">${(lang === 'ta' ? 'விளக்கம்' : 'Explanation')}: ${explanationText}</div>`;
                 reviewItem.innerHTML = `<div class="review-item-qnum">Question ${index + 1}</div> <div class="review-item-question">${questionText}</div> <div class="review-item-details">${detailsHtml}</div>`;
                 reviewContent.appendChild(reviewItem);
             });
             if (reviewData.savedAt) { saveReviewBtn.textContent = "Review Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; }
             else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; }
             else { saveReviewBtn.style.display = 'none'; }
             reviewFilters.style.display = 'block';
              try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err => console.error('MathJax error:', err)); } } catch (e) { console.error("MathJax call failed:", e); }
             filterReviewItems('all');
             reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); });
        }
        function handleReviewFilterClick(event) { /* ... (same as before) ... */
            const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); }
        }
        function filterReviewItems(filter) { /* ... (same as before) ... */
            reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); });
            reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); });
        }
        function exitReview() { /* ... (same as before) ... */
            reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Test Review'; if (reviewLanguageToggle) reviewLanguageToggle.textContent = 'தமிழ்'; currentReviewLanguage = 'en';
        }
        async function saveTestReviewToCloud() { /* ... (same as before) ... */
            if (!currentUser) { alert("Please log in to save."); return; }
            if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new review data or already saved."); return; }
            if (!reviewResultsCache.originalMCQs || reviewResultsCache.originalMCQs.length === 0) { if (!confirm("Warning: Original question data missing. Review might not display correctly. Save anyway?")) { return; } }
            const reviewDataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), };
            saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving...";
            try {
                const newReviewRef = await db.collection('testReviews').add(reviewDataToSave);
                console.log("Review saved:", newReviewRef.id); alert("Test review saved successfully!"); saveReviewBtn.textContent = "Review Saved";
                if (reviewResultsCache) reviewResultsCache.savedAt = new Date();
            } catch (error) {
                console.error("Error saving review:", error); alert("Failed to save review. Try again."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review";
            }
        }


        // --- All Tests List Functions ---
        // ... (loadAndListenForTests, renderAllTestsList, filterTestsInSidebar, handleAllTestsListClick, enterTestTitleEditMode, exitTestTitleEditMode, saveTestTitle, deleteSavedTest, startReattempt remain the same) ...
        function loadAndListenForTests(userId) { /* ... (same as before) ... */
            if (testListListener) { testListListener(); testListListener = null; }
            const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc');
            console.log(`Listening for saved tests for user ${userId}`);
            testListListener = testsRef.onSnapshot(snapshot => {
                allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); });
                console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests");
                renderAllTestsList(allSavedTestsData); filterTestsInSidebar();
            }, error => {
                console.error("Error listening for saved tests:", error);
                allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--error-text);font-size:0.9em;">Error loading tests. Check console & index/rules.</div>`;
                allSavedTestsData = [];
            });
        }
        function renderAllTestsList(tests) { /* ... (same as before) ... */
            allTestsListContainer.innerHTML = '';
            if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>'; return; }
            if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">No saved tests yet.</div>'; }
            else {
                tests.forEach(testData => {
                    const itemElement = document.createElement('div'); itemElement.classList.add('test-list-item'); itemElement.dataset.reviewId = testData.id;
                    const title = testData.testTitle || '(Untitled Test)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date'; const score = testData.summary?.score || 'N/A';
                    const hasReattemptData = testData.originalMCQs && Array.isArray(testData.originalMCQs) && testData.originalMCQs.length > 0 && testData.originalMCQs.every(q => q && q.question && q.options && q.answer && q.explanation);
                    const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info');
                    const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title;
                    const detailsSpan = document.createElement('span'); detailsSpan.classList.add('test-item-details'); detailsSpan.textContent = `Saved: ${date} | Score: ${score}`;
                    const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls');
                    const editBtn = document.createElement('button'); editBtn.innerHTML = EDIT_TEST_ICON; editBtn.title = "Edit test title"; editBtn.dataset.action = "edit-title"; controlsDiv.appendChild(editBtn);
                    const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = DELETE_TEST_ICON; deleteBtn.title = "Delete this saved test"; deleteBtn.dataset.action = "delete-test"; controlsDiv.appendChild(deleteBtn);
                    infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailsSpan); infoDiv.appendChild(controlsDiv);
                    const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions');
                    const viewBtn = document.createElement('button'); viewBtn.textContent = "View Details"; viewBtn.dataset.action = "view"; actionsDiv.appendChild(viewBtn);
                    const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt options" : "Reattempt N/A (Missing data)";
                    reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'Reattempt N/A'}</option><option value="mistaked" ${!hasReattemptData ? 'disabled' : ''}>Mistaked Only</option><option value="skipped" ${!hasReattemptData ? 'disabled' : ''}>Skipped Only</option><option value="both" ${!hasReattemptData ? 'disabled' : ''}>Mistaked & Skipped</option><option value="full" ${!hasReattemptData ? 'disabled' : ''}>Full Test</option>`;
                    reattemptSelect.addEventListener('change', (event) => { const selectedMode = event.target.value; if (selectedMode) { const reviewId = event.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) { startReattempt(reviewId, selectedMode); } event.target.value = ""; } });
                    actionsDiv.appendChild(reattemptSelect);
                    itemElement.appendChild(infoDiv); itemElement.appendChild(actionsDiv); allTestsListContainer.appendChild(itemElement);
                });
            }
        }
        function filterTestsInSidebar() { /* ... (same as before) ... */
            const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0;
            const existingNoResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (existingNoResultsMsg) { existingNoResultsMsg.remove(); }
            items.forEach(item => { const titleElement = item.querySelector('.test-item-title'); const detailsElement = item.querySelector('.test-item-details'); const titleText = titleElement ? titleElement.textContent.toLowerCase() : ''; const detailsText = detailsElement ? detailsElement.textContent.toLowerCase() : ''; const isMatch = titleText.includes(searchTerm) || detailsText.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) { visibleCount++; } });
            if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No tests match your search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); }
        }
        async function handleAllTestsListClick(event) { /* ... (same as before) ... */
            const button = event.target.closest('button[data-action]'); if (!button) return;
            const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.warn("Action button clicked, no review ID found."); return; }
            switch (action) {
                case "view":
                    const reviewData = allSavedTestsData.find(test => test.id === reviewId);
                    if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); displayReview(reviewData); } else { console.error("Could not find review data for ID:", reviewId); alert("Error: Could not load review details."); }
                    break;
                case "edit-title": enterTestTitleEditMode(listItem, reviewId); break;
                case "delete-test":
                    const testTitleSpan = listItem.querySelector('.test-item-title'); const testTitle = testTitleSpan?.textContent || 'this test';
                    if (confirm(`Are you sure you want to permanently delete the saved test "${testTitle}"?`)) { deleteSavedTest(reviewId, listItem); }
                    break;
            }
        }
        function enterTestTitleEditMode(listItem, reviewId) { /* ... (same as before) ... */
            const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailsSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent;
            titleSpan.style.display = 'none'; detailsSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none';
            if (infoDiv.querySelector('.test-item-edit-mode')) return;
            const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode');
            const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100;
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { saveTestTitle(listItem, reviewId, input.value); } else if (e.key === 'Escape') { exitTestTitleEditMode(listItem, currentTitle); } });
            const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save'; saveBtn.onclick = () => saveTestTitle(listItem, reviewId, input.value);
            const cancelBtn = document.createElement('button'); cancelBtn.textContent = 'Cancel'; cancelBtn.onclick = () => exitTestTitleEditMode(listItem, currentTitle);
            editContainer.appendChild(input); editContainer.appendChild(saveBtn); editContainer.appendChild(cancelBtn);
            infoDiv.appendChild(editContainer); input.focus(); input.select();
        }
        function exitTestTitleEditMode(listItem, originalTitle = null) { /* ... (same as before) ... */
            const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailsSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode');
            if (editContainer) { editContainer.remove(); }
            if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; }
            if(titleSpan) titleSpan.style.display = ''; if(detailsSpan) detailsSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = '';
        }
        async function saveTestTitle(listItem, reviewId, newTitle) { /* ... (same as before) ... */
            const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Test title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Test title is too long (max 100 characters)."); return; }
            const testDocRef = db.collection('testReviews').doc(reviewId);
            try {
                await testDocRef.update({ testTitle: trimmedTitle }); console.log("Test title updated:", reviewId, trimmedTitle);
                const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; }
                const testIndex = allSavedTestsData.findIndex(test => test.id === reviewId); if (testIndex > -1) { allSavedTestsData[testIndex].testTitle = trimmedTitle; }
                exitTestTitleEditMode(listItem);
            } catch (error) { console.error("Error updating test title:", error); alert("Failed to update test title. Try again."); }
        }
        async function deleteSavedTest(reviewId, listItemElement) { /* ... (same as before) ... */
             if (!currentUser || !reviewId) return;
             listItemElement.style.opacity = '0.5'; listItemElement.style.pointerEvents = 'none';
             const testDocRef = db.collection('testReviews').doc(reviewId);
             try {
                 await testDocRef.delete(); console.log("Saved test deleted:", reviewId);
                 allSavedTestsData = allSavedTestsData.filter(test => test.id !== reviewId);
                 alert("Saved test deleted.");
             } catch (error) { console.error("Error deleting saved test:", error); alert("Failed to delete saved test. Try again."); listItemElement.style.opacity = '1'; listItemElement.style.pointerEvents = 'auto'; }
        }
        async function startReattempt(reviewId, mode) { /* ... (same as before) ... */
            console.log(`Starting reattempt for review: ${reviewId}, mode: ${mode}`);
            const reviewData = allSavedTestsData.find(test => test.id === reviewId); if (!reviewData) { alert("Error: Could not find data for this review."); return; }
            const originalMCQs = reviewData.originalMCQs; const hasValidReattemptData = originalMCQs && Array.isArray(originalMCQs) && originalMCQs.length > 0 && originalMCQs.every(q => q && q.question && q.options && q.answer && q.explanation);
            if (!hasValidReattemptData) { alert("Error: Cannot reattempt. Original question data is missing or invalid."); return; }
            const reviewQuestionsSummary = reviewData.questions || []; let questionsToReattempt = [];
            switch (mode) {
                case 'mistaked': questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'incorrect'); break;
                case 'skipped': questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'skipped'); break;
                case 'both': questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'incorrect' || reviewQuestionsSummary[index]?.status === 'skipped'); break;
                case 'full': default: questionsToReattempt = [...originalMCQs]; break;
            }
            if (questionsToReattempt.length === 0) { alert(`No questions found for reattempt mode ('${mode}').`); return; }
            const reattemptTitle = `${reviewData.testTitle || 'Test'} (Reattempt: ${mode})`;
            startMockTest(questionsToReattempt, reattemptTitle);
        }


    </script>

</body>
</html>
