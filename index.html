<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chat + Mock Test (v8 - History/Delete)</title>

    <!-- MathJax Configuration -->
    <script> window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},svg:{fontCache:'global'},options:{skipHtmlTags:['script','noscript','style','textarea','pre','code']}}; </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

    <style>
        /* --- Styles (Mostly Unchanged - Added History View, Delete Button, etc.) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
             /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-btn-color: #a85c5c; --delete-btn-hover-color: #dc3545;
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-btn-color: #b07a7a; --delete-btn-hover-color: #ff8a8a; }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* --- Layout & Structure --- */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view, .test-history-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; } /* Added test-history-view */
        .main-content.active, .review-view.active, .test-history-view.active { display: flex; } /* Added test-history-view */
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 20px 10%; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; /* Initially hidden until login */ }

        /* --- Sidebar Elements --- */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; } /* Disabled style for logged out */
         .sidebar-section-title { padding: 15px 20px 5px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; }
         .chat-list { flex-grow: 1; overflow-y: auto; padding: 0 15px; margin-bottom: 10px; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item {
             padding: 8px 30px 8px 10px; /* Added padding-right for delete button */
             margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer;
             white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary);
             transition: background-color 0.2s ease, color 0.2s ease; position: relative; /* Needed for absolute positioning of delete button */
         }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-btn { /* New style for delete button */
             position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
             background: none; border: none; color: var(--delete-btn-color); font-size: 1.2em; line-height: 1;
             padding: 2px 5px; border-radius: 4px; cursor: pointer; display: none; /* Hidden by default */
             transition: color 0.2s ease, background-color 0.2s ease;
         }
         .chat-list-item:hover .delete-chat-btn { display: inline-block; } /* Show on item hover */
         .delete-chat-btn:hover { color: var(--delete-btn-hover-color); background-color: rgba(128, 128, 128, 0.1); }

         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease;}
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; /* Initially hidden */ }
         #view-test-history-btn { /* New Button */
             display: block; width: calc(100% - 30px); margin: 15px 15px 5px;
             background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color);
             border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em;
             transition: background-color 0.2s ease; text-align: center;
         }
         #view-test-history-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
         #view-test-history-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* --- Chat Area Elements --- */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message mjx-container { color: inherit !important; font-size: inherit !important; }

        /* --- Input Area Elements --- */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; } /* Initially hidden */
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--accent-color); }
        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }
        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* --- Mock Test View Styles --- */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- Review View Styles --- */
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn {
            background-color: var(--accent-color); color: var(--send-button-text); border: none;
            border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* --- Test History View Styles (New) --- */
        .test-history-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .history-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .history-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        #test-history-search { /* Search Input Style */
            padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 6px;
            font-size: 0.95em; background-color: var(--input-bg); color: var(--text-primary);
            width: 250px; max-width: 40%;
        }
        #test-history-list { flex-grow: 1; overflow-y: auto; padding: 10px 5px; }
        .history-list-item {
            margin-bottom: 12px; padding: 15px; border: 1px solid var(--border-color);
            border-radius: 6px; background-color: var(--button-bg); display: flex;
            justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .history-list-item.hidden-by-search { display: none; }
        .history-item-info { flex-grow: 1; min-width: 200px; }
        .history-item-info span { display: block; margin-bottom: 4px; font-size: 0.9em; }
        .history-item-info .history-date { color: var(--text-secondary); }
        .history-item-info .history-score { font-weight: bold; color: var(--text-primary); }
        .history-item-actions { display: flex; gap: 8px; flex-wrap: wrap; }
        .history-item-actions button {
             background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color);
             border-radius: 5px; padding: 5px 10px; cursor: pointer; font-size: 0.85em;
             transition: background-color 0.2s ease; white-space: nowrap;
        }
        .history-item-actions button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .history-item-actions button.reattempt-btn { border-color: var(--accent-color); color: var(--accent-color); }
        .history-item-actions button:disabled { opacity: 0.5; cursor: not-allowed; }

        .history-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        #exit-history-btn {
            background-color: var(--accent-color); color: var(--send-button-text); border: none;
            border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #exit-history-btn:hover { background-color: var(--send-button-hover-bg); }
        .no-history-message { padding: 20px; text-align: center; color: var(--text-secondary); font-style: italic; }


    </style>
</head>
<body>

    <!-- App Container -->
    <div class="app-container" id="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">Gemini Chat</div>
            <button class="start-chat-button" id="start-chat" disabled>
                 <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                 Start new chat
            </button>
            <div class="sidebar-section-title">Chats</div>
            <div class="chat-list" id="chat-list">
                 <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
            </div>

            <!-- Added Button to View Test History -->
            <button id="view-test-history-btn" disabled>View Test History</button>

            <div class="sidebar-footer">
                <div class="sidebar-controls">
                     <div class="text-size-controls">
                         <span>Text Size</span>
                         <div class="text-size-buttons">
                             <button id="decrease-text-size" title="Decrease text size" disabled>-</button>
                             <button id="increase-text-size" title="Increase text size" disabled>+</button>
                         </div>
                     </div>
                     <div class="theme-toggle">
                         <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button>
                     </div>
                </div>
                 <div id="auth-controls">
                     <button id="login-google-btn">Login with Google</button>
                     <button id="logout-btn" style="display: none;">Logout</button>
                 </div>
                 <div class="account-info">
                     <div class="account-avatar" id="account-avatar">?</div>
                     <div class="account-details">
                         <div class="account-email" id="account-email">Not logged in</div>
                         <div class="account-plan" id="account-plan"></div>
                     </div>
                 </div>
            </div>
        </div>

        <!-- Main Area Container -->
        <div class="main-container">
            <!-- Chat View -->
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area"></div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="5 questions about US History">5 Qs US History (Check MCQ)</button>
                          <button class="suggestion-chip" data-prompt="What is recursion?">Recursion?</button>
                          <button class="suggestion-chip" data-prompt="Explain $\lim_{x\to 0} \frac{\sin x}{x} = 1$">Limit sin(x)/x ?</button>
                     </div>
                    <div class="input-box">
                        <textarea id="user-input" placeholder="Enter prompt..." rows="1"></textarea>
                        <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Check to generate MCQs based on your prompt"> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                        <button id="send-button" title="Send message" disabled>
                            <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                </div>
            </div>
            <!-- Review View -->
             <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2>Test Review</h2>
                     <div class="review-summary" id="review-summary"></div>
                     <div class="review-filters" id="review-filters">
                         <button data-filter="all" class="active-filter">All</button>
                         <button data-filter="incorrect">Incorrect</button>
                         <button data-filter="skipped">Skipped</button>
                     </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer">
                     <button id="save-review-btn">Save Review</button>
                     <button id="exit-review-btn">Back to Chat</button>
                 </div>
             </div>
             <!-- Test History View (New) -->
             <div class="test-history-view" id="test-history-view">
                 <div class="history-header">
                     <h2>Test History</h2>
                     <input type="search" id="test-history-search" placeholder="Search history...">
                 </div>
                 <div id="test-history-list">
                     <!-- History items will be loaded here -->
                 </div>
                 <div class="history-footer">
                     <button id="exit-history-btn">Back to Chat</button>
                 </div>
             </div>
        </div>
    </div>

    <!-- Mock Test View (Fullscreen Overlay) -->
    <div class="mock-test-view" id="mock-test-view">
        <div class="test-header"> <h2 id="test-title">Mock Test</h2> <div class="test-info"> <span id="question-counter">Q: 1 / N</span> <span id="test-timer">Time: 00:00</span> </div> </div>
        <div class="test-content"> <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div> </div>
        <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        // !!! SECURITY WARNING - Replace with your actual config after testing !!!
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- SHARED, INSECURE KEY
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const historyView = document.getElementById('test-history-view'); // New
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        // Auth buttons
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        // Review elements
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // History elements (New)
        const viewHistoryBtn = document.getElementById('view-test-history-btn');
        const exitHistoryBtn = document.getElementById('exit-history-btn');
        const historyList = document.getElementById('test-history-list');
        const historySearchInput = document.getElementById('test-history-search');

        // --- Config & Constants ---
        const MODEL_NAME="gemini-1.5-flash-latest";
        const API_URL_BASE=`https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=`;
        const STORAGE_KEY_API_KEY='geminiApiKey';
        const NEW_CHAT_TITLE="(New Chat)";
        const TEXT_SIZE_STEP=0.1;
        const MIN_TEXT_SIZE_MULTIPLIER=0.7;
        const MAX_TEXT_SIZE_MULTIPLIER=1.5;
        const LIGHT_THEME_ICON='☀️';
        const DARK_THEME_ICON='🌙';

        // --- State Variables ---
        let API_KEY='';
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory=[];
        let currentTextSizeMultiplier=1.0;
        let currentTheme='light';
        let isTestMode=false;
        let isReviewMode=false;
        let isHistoryMode=false; // New state
        let currentTestMCQs=[];
        let currentQuestionIndex=0;
        let userAnswers=[];
        let testStartTime=null;
        let testTimerInterval=null;
        let generatedMCQData=null;
        let reviewResultsCache = null;
        let activeChatListener = null;
        let chatListListener = null;
        let allHistoryItemsCache = []; // Cache for client-side search

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick); // Will handle delete too
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        // Test listeners
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        // Review listeners
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        // Auth listeners
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // History listeners (New)
        viewHistoryBtn.addEventListener('click', showTestHistory);
        exitHistoryBtn.addEventListener('click', exitHistory);
        historyList.addEventListener('click', handleHistoryListClick);
        historySearchInput.addEventListener('input', handleHistorySearch);


        // --- Initialization Functions ---
        async function initializeApp() {
            loadGeminiApiKey();
            fbAuth.onAuthStateChanged(handleAuthStateChange);
            switchView('chat');
            userInput.focus();
        }

        function loadGeminiApiKey() {
             console.warn("SECURITY WARNING: Gemini API Key is stored in localStorage. This is insecure. Migrate to Cloud Function.");
            const k=localStorage.getItem(STORAGE_KEY_API_KEY);
            if(k){ API_KEY=k; }
            else { API_KEY=prompt("--- INSECURE DEMO ---\nEnter Gemini API Key (stored locally - requires Cloud Function for security):");
                 if(API_KEY){ localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); }
                 else { displayError("Gemini API Key required. Reload to enter."); setLoadingState(true, "API Key Missing"); }
            }
        }

        // --- Authentication Functions ---
        async function signInWithGoogle() { /* ... (no change) ... */
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                setLoadingState(true, "Logging in...");
                await fbAuth.signInWithPopup(provider);
            } catch (error) {
                console.error("Google Sign-In Error:", error);
                displayError(`Login failed: ${error.message}`);
                setLoadingState(false);
            }
        }
        async function signOut() { /* ... (no change) ... */
            try {
                setLoadingState(true, "Logging out...");
                await fbAuth.signOut();
            } catch (error) {
                console.error("Sign Out Error:", error);
                displayError(`Logout failed: ${error.message}`);
                setLoadingState(false);
            }
         }

        function handleAuthStateChange(user) {
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            if (chatListListener) { chatListListener(); chatListListener = null; }
            chatArea.innerHTML = '';
            chatListContainer.innerHTML = '';
            activeChatId = null;
            currentChatHistory = [];

            if (user) {
                currentUser = user;
                console.log("User logged in:", currentUser.uid, currentUser.displayName || currentUser.email);
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User";
                startChatButton.disabled = false;
                decreaseTextBtn.disabled = false;
                increaseTextBtn.disabled = false;
                themeToggleButton.disabled = false;
                viewHistoryBtn.disabled = false; // Enable history button

                sendButton.disabled = false;
                userInput.disabled = false;
                userInput.placeholder = "Enter prompt...";
                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';

                loadUserSettings(currentUser.uid);
                loadAndListenForChats(currentUser.uid);

            } else {
                currentUser = null;
                console.log("User logged out");
                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in";
                accountAvatar.textContent = '?';
                accountPlan.textContent = "";
                startChatButton.disabled = true;
                decreaseTextBtn.disabled = true;
                increaseTextBtn.disabled = true;
                themeToggleButton.disabled = true;
                viewHistoryBtn.disabled = true; // Disable history button

                sendButton.disabled = true;
                userInput.disabled = true;
                userInput.placeholder = "Please log in";
                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';

                renderGreetingOrLoginPrompt();
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>';

                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();
                switchView('chat'); // Ensure back in chat view on logout
            }
             setLoadingState(false); // Ensure loading state is off
        }

        function renderGreetingOrLoginPrompt() { /* ... (no change) ... */
             chatArea.innerHTML = '';
            const g = document.createElement('div');
            g.classList.add('greeting');
            if (currentUser) {
                 g.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`;
                 chatArea.appendChild(g);
                 if (!activeChatId && !isHistoryMode) { // Also check not in history mode
                    displayMessage("Select a chat or start a new one.", 'ai');
                 }
            } else {
                g.innerHTML = `<span class="asterisk">*</span>Welcome!`;
                chatArea.appendChild(g);
                displayMessage("Please log in using Google (button in the sidebar) to start chatting or view your history.", 'ai');
            }
            scrollToBottom(true);
        }

        // --- Settings ---
        async function loadUserSettings(userId) { /* ... (no change) ... */
             const userDocRef = db.collection('users').doc(userId);
            try {
                const docSnap = await userDocRef.get();
                if (docSnap.exists) {
                    const settings = docSnap.data();
                    currentTheme = settings.theme || 'light';
                    currentTextSizeMultiplier = settings.textSizeMultiplier || 1.0;
                    console.log("Loaded user settings:", settings);
                } else {
                    console.log("No user settings found, using defaults and saving.");
                    currentTheme = 'light';
                    currentTextSizeMultiplier = 1.0;
                    await saveUserSettings();
                }
            } catch (error) {
                console.error("Error loading user settings:", error);
                currentTheme = 'light';
                currentTextSizeMultiplier = 1.0;
            }
            applyTheme();
            applyTextSize();
        }
        async function saveUserSettings() { /* ... (no change) ... */
             if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = { theme: currentTheme, textSizeMultiplier: currentTextSizeMultiplier };
            try {
                await userDocRef.set(settings, { merge: true });
                console.log("User settings saved:", settings);
            } catch (error) { console.error("Error saving user settings:", error); }
        }
        function applyTheme() { /* ... (no change) ... */
             if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light"; }
             else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark"; }
        }
        function toggleTheme() { /* ... (no change) ... */
             if (!currentUser) return;
             currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings();
        }
        function applyTextSize() { /* ... (no change) ... */
             const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`;
             document.documentElement.style.setProperty('--message-font-size', newSize); console.log("Applied text size multiplier:", currentTextSizeMultiplier);
        }
        function adjustTextSize(change) { /* ... (no change) ... */
             if (!currentUser) return;
            let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change));
            newMultiplier = Math.round(newMultiplier * 10) / 10;
            if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); }
        }

        // --- Chat Storage & Loading (Firestore) ---

        function loadAndListenForChats(userId) {
            if (chatListListener) { chatListListener(); chatListListener = null; }

            const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc');

            console.log(`Listening for chats for user ${userId}`);
            chatListListener = chatsRef.onSnapshot(snapshot => {
                const chats = [];
                snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); });
                console.log("Received chat list snapshot:", chats);
                renderSidebarChatList(chats); // Render sidebar with new data

                // Determine which chat to load/display (if not already active or in another view)
                if (!isTestMode && !isReviewMode && !isHistoryMode) { // Only switch chat if in chat view
                    let chatToLoad = null;
                    if (activeChatId && chats.some(c => c.id === activeChatId)) {
                        chatToLoad = activeChatId; // Keep current active chat
                    } else if (chats.length > 0) {
                        chatToLoad = chats[0].id; // Load the newest one
                    }

                    if (chatToLoad && chatToLoad !== activeChatId) {
                         console.log("Switching to chat:", chatToLoad);
                         switchChat(chatToLoad); // Switch including loading messages
                    } else if (!chatToLoad && activeChatId) {
                         // The active chat was deleted, clear the view
                         activeChatId = null;
                         if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                         renderGreetingOrLoginPrompt();
                    } else if (!chatToLoad && !activeChatId) {
                        // No chats exist for the user
                        renderGreetingOrLoginPrompt();
                    }
                } else {
                    // If in test/review/history mode, just update the highlight in sidebar
                    highlightActiveChatInSidebar();
                }

            }, error => {
                console.error("Error listening for chats:", error);
                displayError("Could not load chat list.");
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Error loading chats.</div>';
            });
        }

        function renderSidebarChatList(chats) {
            chatListContainer.innerHTML = '';
            if (!currentUser) {
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in.</div>';
                return;
            }
            if (chats.length === 0) {
                const i = document.createElement('div');
                i.textContent = "No chats yet.";
                i.style.cssText = "padding:10px;color:var(--text-secondary);font-size:0.9em;";
                chatListContainer.appendChild(i);
            } else {
                chats.forEach(c => {
                    const item = document.createElement('div');
                    item.classList.add('chat-list-item');
                    let title = c.title || '(Untitled)';
                    if (typeof title !== 'string' || title.trim() === '') title = '(Untitled Chat)';
                    item.textContent = title;
                    item.dataset.id = c.id;

                    // Add Delete Button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-chat-btn');
                    deleteBtn.innerHTML = '×'; // 'X' symbol
                    deleteBtn.title = "Delete Chat";
                    deleteBtn.dataset.id = c.id; // Store ID on button too for easier access
                    item.appendChild(deleteBtn);

                    chatListContainer.appendChild(item);
                });
            }
             highlightActiveChatInSidebar();
        }

        function highlightActiveChatInSidebar() { /* ... (no change) ... */
             const items = chatListContainer.querySelectorAll('.chat-list-item');
             items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); });
         }

        async function createNewChat() {
            if (!currentUser) return;
            setLoadingState(true, "Creating chat...");
            const newChatRef = db.collection('chats').doc();
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            try {
                await newChatRef.set({
                    userId: currentUser.uid,
                    title: NEW_CHAT_TITLE, // Will be updated by first message
                    createdAt: timestamp,
                    lastUpdated: timestamp
                });
                console.log("New chat document created:", newChatRef.id);
                // Listener will pick it up and potentially switch to it
                switchView('chat'); // Ensure we are in chat view
            } catch (error) {
                console.error("Error creating new chat:", error);
                displayError("Failed to create chat.");
            } finally {
                setLoadingState(false);
                userInput.focus();
            }
        }

        function handleChatListClick(event) {
            const item = event.target.closest('.chat-list-item');
            const deleteBtn = event.target.closest('.delete-chat-btn');
            const clickedId = item?.dataset?.id;

            if (deleteBtn) {
                event.stopPropagation(); // Prevent chat switching when clicking delete
                const chatIdToDelete = deleteBtn.dataset.id;
                if (chatIdToDelete) {
                    deleteChat(chatIdToDelete);
                }
            } else if (item && clickedId && clickedId !== activeChatId) {
                console.log("Chat list item clicked:", clickedId);
                switchChat(clickedId);
            }
        }

        // --- New Function: Delete Chat ---
        async function deleteChat(chatId) {
            if (!currentUser || !chatId) return;

            const chatToDelete = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`);
            const title = chatToDelete ? chatToDelete.textContent.replace('×', '').trim() : `Chat ID ${chatId}`;

            if (!confirm(`Are you sure you want to delete the chat "${title}"? This cannot be undone.`)) {
                return;
            }

            console.log("Attempting to delete chat:", chatId);
            const chatDocRef = db.collection('chats').doc(chatId);

            try {
                // --- IMPORTANT LIMITATION ---
                // This only deletes the main chat document.
                // Messages in the subcollection 'messages' will be orphaned.
                // A Cloud Function is the recommended way to delete subcollections.
                // See: https://firebase.google.com/docs/firestore/manage-data/delete-data#delete_collections
                console.warn(`Deleting chat document ${chatId}. Messages subcollection will be orphaned (client-side limitation).`);

                await chatDocRef.delete();
                console.log("Chat document deleted:", chatId);

                // If the deleted chat was the active one, clear the view
                if (activeChatId === chatId) {
                    activeChatId = null;
                    if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    chatArea.innerHTML = '';
                    currentChatHistory = [];
                    renderGreetingOrLoginPrompt(); // Show default greeting
                }
                // The chatListListener will automatically update the sidebar UI.

            } catch (error) {
                console.error("Error deleting chat:", error);
                displayError(`Failed to delete chat "${title}".`);
            }
        }


        function switchChat(chatId) {
             if (!currentUser || !chatId || chatId === activeChatId) return;
             // Ensure we are in the chat view before switching
             switchView('chat'); // This resets modes like isHistoryMode
             console.log("Switching to chat:", chatId);
             activeChatId = chatId;
             highlightActiveChatInSidebar();
             loadAndListenForActiveChat(chatId);
             userInput.focus();
        }

        // --- Message Loading (Firestore) ---
        function loadAndListenForActiveChat(chatId) { /* ... (no change from previous version, handles loading messages) ... */
            if (!currentUser || !chatId) { console.log("Cannot load messages: No user or chatId."); chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); return; }
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            highlightActiveChatInSidebar();
            const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
            chatArea.innerHTML = ''; const loadingMsg = displayMessage("Loading chat...", 'ai', ['thinking']);
            console.log(`Listening for messages in chat ${chatId}`);
            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages");
                removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];
                if (snapshot.empty) { console.log("Chat is empty."); renderGreetingOrLoginPrompt(); }
                else { snapshot.forEach(doc => { const msgData = doc.data(); const text = msgData.text || ""; const role = msgData.role || "model"; currentChatHistory.push({ role: role, parts: [{ text: text }] }); displayMessage(text, role, [], null, msgData); }); }
                scrollToBottom(true);
            }, error => {
                console.error(`Error listening for messages in chat ${chatId}:`, error); displayError("Could not load messages for this chat."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];
            });
         }

        // --- Message Sending (Gemini API & Firestore Save) ---
        async function handleSendMessage() {
             // --- Pre-send Checks ---
             if (!API_KEY) { displayError("Gemini API Key not set. Reload."); return; }
             if (!currentUser) { displayError("Please log in first."); return; }
             if (!activeChatId) { displayError("Please select or create a chat first."); return; } // Should not happen if UI is correct
             const txt = userInput.value.trim();
             if (!txt || sendButton.disabled) return;

             setLoadingState(true, "Sending...");
             const isMCQRequest = mcqModeCheckbox.checked;
             const userMessageText = txt;
             userInput.value = ''; autoGrowTextarea();
             if (isMCQRequest) mcqModeCheckbox.checked = false;

             const timestamp = firebase.firestore.FieldValue.serverTimestamp();
             const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
             const chatDocRef = db.collection('chats').doc(activeChatId);

             // 1. Save User Message
             const userMsgData = { role: "user", text: userMessageText, timestamp: timestamp };
             try {
                 await messagesColRef.add(userMsgData);
                 await chatDocRef.update({ lastUpdated: timestamp });
                 console.log("User message saved.");
             } catch(error) {
                 console.error("Error saving user message:", error); displayError("Failed to send."); setLoadingState(false); return;
             }

             // 2. Update Title if First Message (Check current title *before* API call)
             try {
                 const chatDocSnap = await chatDocRef.get();
                 if (chatDocSnap.exists && chatDocSnap.data().title === NEW_CHAT_TITLE) {
                     // Check if there are *any* user messages in history *before this one*.
                     // If the history loaded by the listener doesn't contain a user message yet,
                     // this is effectively the first one being processed.
                     const historyHasUserMessage = currentChatHistory.some(m => m.role === 'user');
                     if (!historyHasUserMessage) {
                         const generatedTitle = generateChatTitle([{ parts: [{ text: userMessageText }] }]); // Pass only current message
                         if (generatedTitle !== NEW_CHAT_TITLE) {
                             await updateActiveChatTitle(generatedTitle); // Update Firestore
                         }
                     }
                 }
             } catch (titleError) { console.error("Error checking/updating chat title:", titleError); }

             // 3. Prepare for API Call
             const thinking = displayMessage("Thinking", 'ai', ['thinking']);
             // Build history - include the message just sent for the API context
             const requestHistory = [...currentChatHistory, { role: "user", parts: [{ text: userMessageText }] }];
             let modifiedPrompt = userMessageText;
             if (isMCQRequest) { /* ... (MCQ prompt modification - no change) ... */
                 modifiedPrompt = `${userMessageText}\n\nPlease provide the response strictly in JSON format... Example: \`\`\`json\n[{"question":"Capital of France?","options":["A) Berlin","B) Paris","C) Rome","D) Madrid"],"answer":"B"}]\n\`\`\` ...`;
                 requestHistory[requestHistory.length - 1] = { role: "user", parts: [{ text: modifiedPrompt }] };
             }

             // 4. Call Gemini API
             console.warn("Calling Gemini API using client-side key. Replace with Cloud Function.");
             try {
                 const response = await fetch(API_URL_BASE + API_KEY, { /* ... (API call options - no change) ... */
                      method: 'POST', headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ contents: requestHistory, safetySettings: [ /* ... */ ] }),
                 });
                 removeMessageElement(thinking);

                 let aiMsgData = { role: "model", text: "Error: No response.", timestamp: firebase.firestore.FieldValue.serverTimestamp() };

                 if (!response.ok) { /* ... (Error handling - no change) ... */
                     let err = { message: `API error (${response.status})` }; try { err = (await response.json()).error || err; } catch {} console.error("API Error:", err); aiMsgData.text = `Error: ${err.message || "Unknown API error"}`; displayError(aiMsgData.text); if(response.status===400 && err.message?.toLowerCase().includes('api key not valid')){ localStorage.removeItem(STORAGE_KEY_API_KEY); API_KEY=''; displayError("Invalid Gemini Key cleared. Reload."); }
                 } else { // Handle success
                     const data = await response.json();
                     let aiTxt = "Sorry, empty response."; let blocked = false;
                     if (data.promptFeedback?.blockReason) { /* ... (Block reason handling - no change) ... */
                         aiTxt = `Blocked: ${data.promptFeedback.blockReason}`; blocked = true; aiMsgData.text = aiTxt; displayMessage(aiTxt,'ai',['error-message']);
                     } else if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                         aiTxt = data.candidates[0].content.parts[0].text;
                         aiMsgData.text = aiTxt; // Default text to save
                         let processedForMCQ = false;
                         if (isMCQRequest && !blocked) { /* ... (MCQ JSON parsing - no change) ... */
                              try {
                                 const jsonMatch = aiTxt.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : aiTxt.trim();
                                 if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                     const mcqs = JSON.parse(jsonString);
                                     if (Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q.question && Array.isArray(q.options) && q.options.length > 1 && q.answer)) { // Basic validation
                                         const summaryText = `Generated ${mcqs.length} MCQs. Click below to start the test.`;
                                         aiMsgData.text = summaryText; aiMsgData.mcqData = mcqs; // Store MCQs in Firestore
                                         console.log("MCQs parsed, saving to Firestore:", mcqs); processedForMCQ = true;
                                     } else { console.warn("MCQ JSON validation failed."); }
                                 } else { console.warn("MCQ response not JSON array."); }
                             } catch (parseError) { console.error("Failed to parse MCQ JSON:", parseError); }
                         }
                         // If not processed as MCQ, aiMsgData.text already holds the normal response.
                     } else { console.warn("Unexpected API response format:", data); aiMsgData.text = "Error: Invalid response format."; displayError(aiMsgData.text); }
                 }
                 // 5. Save AI Response/Error
                 try {
                     await messagesColRef.add(aiMsgData);
                     await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); // Update again
                     console.log("AI response/error saved.");
                 } catch (saveError) { console.error("Error saving AI response:", saveError); displayError("Error saving response."); }

             } catch (error) { /* ... (Fetch/Network error handling - no change) ... */
                 console.error("Fetch/Processing Error:", error); removeMessageElement(thinking); const errorText = `Error: ${error.message || "Network error."}`; displayError(errorText);
                 try { await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() }); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); } catch (saveError) { console.error("Error saving network error message:", saveError); }
             } finally {
                 setLoadingState(false);
                 if (!isTestMode && !isReviewMode && !isHistoryMode) userInput.focus(); // Focus only if in chat view
             }
        }

        function generateChatTitle(historyForTitle) { /* ... (no change - generates title) ... */
             const firstUserMessage = historyForTitle.find(m => m.role === 'user');
             if (firstUserMessage?.parts[0]?.text) {
                 const text = firstUserMessage.parts[0].text;
                 const title = text.split(/[\s\n]+/).slice(0, 5).join(' ').replace(/[.,!?;:]$/, '');
                 return title.length > 35 ? title.substring(0, 32) + '...' : (title || NEW_CHAT_TITLE);
             } return NEW_CHAT_TITLE;
         }

        async function updateActiveChatTitle(newTitle) { /* ... (no change - updates Firestore) ... */
             if (!currentUser || !activeChatId || !newTitle || newTitle === NEW_CHAT_TITLE) return;
             const chatDocRef = db.collection('chats').doc(activeChatId);
             try { await chatDocRef.update({ title: newTitle }); console.log(`Chat ${activeChatId} title updated: ${newTitle}`); }
             catch (error) { console.error("Error updating chat title:", error); }
         }


        // --- UI & Message Display ---
        function autoGrowTextarea() { /* ... */ }
        function handleInputKeydown(event) { /* ... */ }
        function handleSuggestionClick(event) { /* ... */ }
        function displayError(text) { displayMessage(`Error: ${text}`, 'ai', ['error-message']); }
        function scrollToBottom(immediate = false) { /* ... */ }
        function removeMessageElement(element) { /* ... */ }

        function setLoadingState(isLoading, message = "Generating...") {
             const isDisabled = isLoading || !currentUser; // Simplified: disable mainly if loading or logged out
             const isInputDisabled = isDisabled || !activeChatId; // Input also disabled if no chat selected

             userInput.disabled = isInputDisabled;
             sendButton.disabled = isInputDisabled;
             mcqModeCheckbox.disabled = isInputDisabled;

             if (isLoading) { userInput.placeholder = message; }
             else if (!currentUser) { userInput.placeholder = "Please log in"; }
             else if (!activeChatId && !isHistoryMode) { userInput.placeholder = "Select or create a chat"; } // More specific
             else if (!isHistoryMode) { userInput.placeholder = "Enter prompt..."; } // Default when ready

             startChatButton.disabled = isDisabled;
             viewHistoryBtn.disabled = isDisabled; // Also disable history button when loading/logged out
         }

        function switchView(viewName) {
             console.log("Switching view to:", viewName);
             chatView.classList.remove('active');
             reviewView.classList.remove('active');
             testView.classList.remove('active');
             historyView.classList.remove('active'); // New
             appContainer.classList.remove('hidden'); // Assume visible by default

             isTestMode = false; isReviewMode = false; isHistoryMode = false; // Reset all modes

             if (viewName === 'test') {
                 appContainer.classList.add('hidden');
                 testView.classList.add('active');
                 isTestMode = true;
             } else if (viewName === 'review') {
                 reviewView.classList.add('active');
                 isReviewMode = true;
             } else if (viewName === 'history') { // New
                 historyView.classList.add('active');
                 isHistoryMode = true;
             } else { // Default to chat view
                 chatView.classList.add('active');
             }

             // Stop test timer if switching away from test view
             if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; }
             // Update input placeholder based on view
             setLoadingState(false); // Refresh placeholder etc.
         }

        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) { /* ... (no change, handles MCQ offer) ... */
             const element = document.createElement('div'); element.classList.add('message', `${sender}-message`, ...cssClasses);
             let formattedText = text.replace(/</g, "<").replace(/>/g, ">").replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/```([\s\S]*?)```/g, (m, c) => `<pre><code>${c.replace(/</g, "<").replace(/>/g, ">")}</code></pre>`).replace(/`([^`]+)`/g, (m, c) => `<code>${c.replace(/</g, "<").replace(/>/g, ">")}</code>`).replace(/\n/g, '<br>');
             element.innerHTML = formattedText;
             if (messageData?.role === 'model' && messageData.mcqData && Array.isArray(messageData.mcqData)) { console.log("Rendering MCQ offer:", messageData.mcqData.length); displayMCQOffer(messageData.mcqData, element); }
             else if (appendHtml) { const tempDiv = document.createElement('div'); tempDiv.innerHTML = appendHtml; while (tempDiv.firstChild) element.appendChild(tempDiv.firstChild); }
             chatArea.appendChild(element);
             try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([element]).catch(err => console.error('MathJax typeset error:', err)); } } catch (e) { console.error("MathJax call failed:", e); }
             return element;
        }

        // --- MCQ/Test Specific Functions ---
        function handleChatAreaClick(event) { /* ... (no change - starts test from chat offer) ... */
             if (event.target.classList.contains('start-test-button')) { const mcqs = generatedMCQData; if (mcqs) { startMockTest(mcqs); generatedMCQData = null; } else { console.error("MCQ data not found."); displayError("Could not start test."); } }
        }
        function displayMCQOffer(mcqs, aiMessageElement) { /* ... (no change - displays start button in chat) ... */
             generatedMCQData = mcqs; const buttonHtml = `<button class="start-test-button">Start Mock Test (${mcqs.length} Questions)</button>`; const tempDiv = document.createElement('div'); tempDiv.style.marginTop = '10px'; tempDiv.innerHTML = buttonHtml; aiMessageElement.appendChild(tempDiv); scrollToBottom();
        }

        function startMockTest(mcqs, titlePrefix = "Mock Test") { // Added optional title prefix
            if (!currentUser) { displayError("Please log in."); return; }
            if (!mcqs || mcqs.length === 0) { displayError("No questions available."); return; }
            console.log(`Starting test: ${titlePrefix} with ${mcqs.length} Qs.`);

            // Ensure MCQs have the 'answer' field (needed by displayTestQuestion logic)
            // This might be needed if reattempting from saved review which might not store the letter.
            const processedMcqs = mcqs.map(q => {
                if (q.answer) return q; // Already has answer letter
                if (q.correctAnswer && q.options) { // Reconstruct from review data if needed
                    return {
                        ...q, // Keep other fields like question, options
                        answer: findCorrectAnswerLetter(q.options, q.correctAnswer) || '?'
                    };
                }
                return { ...q, answer: '?' }; // Fallback
            });

            currentTestMCQs = processedMcqs;
            currentQuestionIndex = 0;
            userAnswers = new Array(processedMcqs.length).fill(null);
            testStartTime = Date.now();
            reviewResultsCache = null;

            switchView('test');
            displayTestQuestion(0);
            startTestTimer();
            testTitle.textContent = `${titlePrefix} (${processedMcqs.length} Qs)`;
        }

        function displayTestQuestion(index) { /* ... (no change) ... */
             if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const q = currentTestMCQs[index]; testQuestionNumber.textContent = `Question ${index + 1}`; testQuestion.innerHTML = q.question; testOptionsContainer.innerHTML = ''; const options = Array.isArray(q.options) ? q.options : []; options.forEach((opt, i) => { const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = i; input.checked = (userAnswers[index] === i); input.onchange = () => handleOptionSelect(i); label.appendChild(input); label.appendChild(document.createTextNode(` ${opt || '(Empty)'}`)); testOptionsContainer.appendChild(label); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax typeset error:',err)); } } catch(e){ console.error("MathJax call failed:",e); } prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`;
        }
        function handleOptionSelect(optionIndex) { /* ... (no change) ... */
             if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option index ${optionIndex}`); }
        }
        function handleTestNavigation(direction) { /* ... (no change) ... */
            let newIndex=currentQuestionIndex; if(direction==='prev'&¤tQuestionIndex>0){newIndex--;}else if(direction==='next'&¤tQuestionIndex<currentTestMCQs.length-1){newIndex++;} if(newIndex!==currentQuestionIndex){displayTestQuestion(newIndex);}
        }
        function startTestTimer() { /* ... (no change, but reset start time is important - checked startMockTest) ... */
            if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000); const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0'); const seconds = (elapsedSeconds % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${minutes}:${seconds}`; }, 1000);
        }
        function submitTest() { /* ... (no change) ... */
             if (!confirm("Submit the test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = endTime - testStartTime; console.log("Submitting test. Time:", timeTakenMs); switchView('review'); displayReview(timeTakenMs);
        }

        // --- Review Functions ---
        function displayReview(timeTakenMs) { /* ... (Mostly unchanged, ensure reviewResultsCache is built correctly) ... */
              reviewContent.innerHTML = ''; saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review";
              if (!currentTestMCQs || currentTestMCQs.length === 0) { reviewSummary.innerHTML = "<span>No test data.</span>"; return; }
              let correct=0, incorrect=0, skipped=0;
              reviewResultsCache = { questions: [], summary: {}, testDate: new Date().toISOString(), timeTakenMs: timeTakenMs };
              currentTestMCQs.forEach((q, index) => {
                  const userAnswerIndex = userAnswers[index]; let userAnswerText = "Skipped"; let status = "skipped"; let itemClass = "status-skipped"; let answerClass = "user-answer-skipped";
                  const options = Array.isArray(q.options) ? q.options : [];
                  // Find correct answer text using the 'answer' letter from the test data
                  const correctAnswerLetter = q.answer?.trim().toUpperCase();
                  const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                  const correctAnswerText = (correctAnswerIndex >= 0 && correctAnswerIndex < options.length) ? options[correctAnswerIndex] : "N/A";

                  if (userAnswerIndex !== null && userAnswerIndex >= 0 && userAnswerIndex < options.length) {
                      userAnswerText = options[userAnswerIndex];
                      if (userAnswerIndex === correctAnswerIndex) { status = "correct"; itemClass = "status-correct"; answerClass = "user-answer-correct"; correct++; }
                      else { status = "incorrect"; itemClass = "status-incorrect"; answerClass = "user-answer-incorrect"; incorrect++; }
                  } else if (userAnswerIndex !== null) { userAnswerText = "Invalid"; status = "incorrect"; itemClass = "status-incorrect"; answerClass = "user-answer-incorrect"; incorrect++; }
                  else { skipped++; }

                  reviewResultsCache.questions.push({ question: q.question, options: options, correctAnswer: correctAnswerText, userAnswer: userAnswerText, status: status }); // Save detailed results

                  const item = document.createElement('div'); item.classList.add('review-item', itemClass); item.dataset.status = status;
                  let detailsHtml = `<span class="${answerClass}">Your Answer: ${userAnswerText}</span>`;
                  if (status !== 'correct') { detailsHtml += `<br><span class="correct-answer">Correct Answer: ${correctAnswerText}</span>`; }
                  item.innerHTML = `<div class="review-item-qnum">Question ${index + 1}</div> <div class="review-item-question">${q.question}</div> <div class="review-item-details">${detailsHtml}</div>`;
                  reviewContent.appendChild(item);
              });
              const total = currentTestMCQs.length; const score = `${correct}/${total}`; const timeSeconds = Math.round(timeTakenMs / 1000); const minutes = Math.floor(timeSeconds / 60); const seconds = timeSeconds % 60; const timeString = `${minutes}m ${seconds}s`;
              reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`;
              reviewResultsCache.summary = { score, correct, incorrect, skipped, timeString }; // Save summary too
              try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax typeset error:',err)); } } catch(e){ console.error("MathJax call failed:",e); }
              filterReviewItems('all');
        }
        function handleReviewFilterClick(event) { /* ... (no change) ... */
             const button=event.target.closest('button[data-filter]'); if(button){filterReviewItems(button.dataset.filter);}
        }
        function filterReviewItems(filter) { /* ... (no change) ... */
             reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); });
             reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.classList.contains(`status-${filter}`); item.classList.toggle('hidden-by-filter', !show); });
        }
        function exitReview() { /* ... (no change) ... */
            switchView('chat'); reviewResultsCache = null;
        }
        async function saveTestReviewToCloud() { /* ... (no change - saves reviewResultsCache) ... */
             if (!currentUser) { alert("Log in to save."); return; } if (!reviewResultsCache) { alert("No review data."); return; }
             const reviewDataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp() };
             saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving...";
             try { const newReviewRef = await db.collection('testReviews').add(reviewDataToSave); console.log("Review saved:", newReviewRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; }
             catch (error) { console.error("Error saving review:", error); alert("Failed to save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; }
        }

        // --- Test History Functions (New) ---

        function showTestHistory() {
            if (!currentUser) return;
            switchView('history');
            loadAndDisplayTestHistory();
        }

        function exitHistory() {
            switchView('chat');
            historySearchInput.value = ''; // Clear search on exit
            allHistoryItemsCache = []; // Clear cache
        }

        async function loadAndDisplayTestHistory() {
            if (!currentUser) return;
            historyList.innerHTML = '<div class="info-message thinking">Loading history...</div>';
            allHistoryItemsCache = []; // Clear previous cache

            try {
                const querySnapshot = await db.collection('testReviews')
                                             .where('userId', '==', currentUser.uid)
                                             .orderBy('savedAt', 'desc')
                                             .get();

                historyList.innerHTML = ''; // Clear loading message
                if (querySnapshot.empty) {
                    historyList.innerHTML = '<div class="no-history-message">No saved test history found.</div>';
                    return;
                }

                querySnapshot.forEach(doc => {
                    const reviewData = doc.data();
                    const reviewId = doc.id;
                    allHistoryItemsCache.push({ id: reviewId, data: reviewData }); // Store for search
                    const listItem = createHistoryListItem(reviewId, reviewData);
                    historyList.appendChild(listItem);
                });
                 // Apply initial search filter if any text is present (e.g., browser autofill)
                 handleHistorySearch();

            } catch (error) {
                console.error("Error loading test history:", error);
                historyList.innerHTML = '<div class="info-message error-message">Failed to load test history.</div>';
            }
        }

        function createHistoryListItem(id, data) {
            const item = document.createElement('div');
            item.classList.add('history-list-item');
            item.dataset.id = id; // Store ID on the item itself

            const date = data.savedAt?.toDate() || new Date(data.testDate); // Prefer savedAt, fallback to testDate
            const dateString = date.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
            const score = data.summary?.score || 'N/A';
            const time = data.summary?.timeString || '';
            const qCount = data.questions?.length || 0;
            const incorrectCount = data.summary?.incorrect || 0;
            const skippedCount = data.summary?.skipped || 0;

             // Store searchable text content within the element (hidden or visible)
             // Include date, score, and maybe first question text for better search
             const firstQuestion = data.questions?.[0]?.question?.substring(0, 50) || '';
             item.dataset.searchText = `${dateString} ${score} ${firstQuestion}`.toLowerCase();


            item.innerHTML = `
                <div class="history-item-info">
                    <span class="history-date">${dateString}</span>
                    <span class="history-score">Score: ${score} (${qCount} Qs)</span>
                    ${time ? `<span>Time: ${time}</span>` : ''}
                </div>
                <div class="history-item-actions">
                    <button class="view-review-btn" data-id="${id}">View Review</button>
                    <button class="reattempt-btn" data-id="${id}" ${qCount === 0 ? 'disabled' : ''}>Reattempt</button>
                    <button class="reattempt-mistakes-btn" data-id="${id}" ${incorrectCount + skippedCount === 0 ? 'disabled' : ''}>
                        Reattempt Mistakes (${incorrectCount + skippedCount})
                    </button>
                </div>
            `;
            return item;
        }

        function handleHistoryListClick(event) {
            const viewBtn = event.target.closest('.view-review-btn');
            const reattemptBtn = event.target.closest('.reattempt-btn');
            const reattemptMistakesBtn = event.target.closest('.reattempt-mistakes-btn');
            const reviewId = viewBtn?.dataset.id || reattemptBtn?.dataset.id || reattemptMistakesBtn?.dataset.id;

            if (!reviewId) return;

            if (viewBtn) {
                console.log("View Review clicked:", reviewId);
                loadAndDisplaySpecificReview(reviewId);
            } else if (reattemptBtn) {
                console.log("Reattempt clicked:", reviewId);
                startReattempt(reviewId, false); // false = full reattempt
            } else if (reattemptMistakesBtn) {
                console.log("Reattempt Mistakes clicked:", reviewId);
                startReattempt(reviewId, true); // true = mistakes/skipped only
            }
        }

        async function loadAndDisplaySpecificReview(reviewId) {
            // Find cached data first
            const cached = allHistoryItemsCache.find(item => item.id === reviewId);
            if (cached?.data) {
                console.log("Displaying review from cache:", reviewId);
                displayReviewFromData(cached.data);
            } else {
                // Fetch from Firestore if not cached (shouldn't happen often with current flow)
                console.log("Fetching specific review from Firestore:", reviewId);
                try {
                    const docSnap = await db.collection('testReviews').doc(reviewId).get();
                    if (docSnap.exists) {
                         displayReviewFromData(docSnap.data());
                    } else {
                        displayError("Could not find the selected review.");
                    }
                } catch (error) {
                    console.error("Error fetching specific review:", error);
                    displayError("Failed to load the review details.");
                }
            }
        }

        // Displays a previously saved review (data from Firestore) in the Review View
        function displayReviewFromData(reviewData) {
            if (!reviewData || !reviewData.questions || !reviewData.summary) {
                displayError("Invalid review data format.");
                return;
            }
             switchView('review'); // Switch to the review view

             reviewContent.innerHTML = ''; // Clear previous content
             saveReviewBtn.disabled = true; // Disable saving again
             saveReviewBtn.textContent = "Review Loaded";

             reviewData.questions.forEach((q, index) => {
                 const item = document.createElement('div');
                 item.classList.add('review-item', `status-${q.status}`);
                 item.dataset.status = q.status;

                 let detailsHtml = `<span class="${q.status === 'correct' ? 'user-answer-correct' : q.status === 'incorrect' ? 'user-answer-incorrect' : 'user-answer-skipped'}">Your Answer: ${q.userAnswer}</span>`;
                 if (q.status !== 'correct') {
                     detailsHtml += `<br><span class="correct-answer">Correct Answer: ${q.correctAnswer}</span>`;
                 }

                 item.innerHTML = `
                     <div class="review-item-qnum">Question ${index + 1}</div>
                     <div class="review-item-question">${q.question}</div>
                     <div class="review-item-details">${detailsHtml}</div>
                 `;
                 reviewContent.appendChild(item);
             });

             // Display Summary
             const { score, correct, incorrect, skipped, timeString } = reviewData.summary;
             reviewSummary.innerHTML = `
                 <span>Score: ${score}</span>
                 <span class="score-correct">Correct: ${correct}</span>
                 <span class="score-incorrect">Incorrect: ${incorrect}</span>
                 <span class="score-skipped">Skipped: ${skipped}</span>
                 <span>Total Time: ${timeString}</span>
             `;

              // Typeset MathJax
              try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax error:',err)); } } catch(e){ console.error("MathJax call failed:",e); }

             filterReviewItems('all'); // Apply default filter
        }


        async function startReattempt(reviewId, mistakesOnly = false) {
            // Find cached data first
            const cached = allHistoryItemsCache.find(item => item.id === reviewId);
            let reviewData = cached?.data;

            if (!reviewData) {
                console.log("Fetching review data for reattempt:", reviewId);
                 try {
                    const docSnap = await db.collection('testReviews').doc(reviewId).get();
                    if (docSnap.exists) { reviewData = docSnap.data(); }
                    else { displayError("Could not find review data to reattempt."); return; }
                 } catch (error) { displayError("Failed to load review data for reattempt."); return; }
            }

            if (!reviewData?.questions) { displayError("Review data missing questions."); return; }

            let questionsToAttempt = reviewData.questions;
            let titlePrefix = "Reattempt";

            if (mistakesOnly) {
                questionsToAttempt = reviewData.questions.filter(q => q.status === 'incorrect' || q.status === 'skipped');
                titlePrefix = "Reattempt Mistakes";
                if (questionsToAttempt.length === 0) {
                    alert("No incorrect or skipped questions to reattempt!");
                    return;
                }
            }

            // Map saved question data to the format needed by startMockTest
            // (Ensuring 'question', 'options', and 'answer' letter are present)
             const mcqsForTest = questionsToAttempt.map(q => ({
                 question: q.question,
                 options: q.options,
                 answer: findCorrectAnswerLetter(q.options, q.correctAnswer) || '?' // Regenerate letter needed for test grading
             }));


            startMockTest(mcqsForTest, titlePrefix);
        }

        // Helper to find the answer letter ('A', 'B', 'C', 'D') from options and correct text
        function findCorrectAnswerLetter(options, correctAnswerText) {
            if (!Array.isArray(options) || !correctAnswerText) return null;
            const index = options.findIndex(opt => opt === correctAnswerText);
            if (index !== -1) {
                return String.fromCharCode('A'.charCodeAt(0) + index);
            }
            return null; // Not found
        }

        function handleHistorySearch() {
            const searchTerm = historySearchInput.value.toLowerCase().trim();
            const items = historyList.querySelectorAll('.history-list-item');

            items.forEach(item => {
                 // Use the pre-stored searchable text
                const itemText = item.dataset.searchText || '';
                const isMatch = itemText.includes(searchTerm);
                item.classList.toggle('hidden-by-search', !isMatch);
            });
        }


    </script>

</body>
</html>
